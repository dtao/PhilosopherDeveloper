As I'm sure plenty of you already know (the title of this blog is a bit of a giveaway), I was a **philosophy** major in college. Which means I was *not* a C.S. major. But that's not the full extent of it: I didn't *minor* in C.S., either; I actually took *absolutely no computer sciences courses at all* in college.

I did recently receive an M.S. in *software engineering* from Carnegie Mellon; but the courses in that program were higher-level in nature: software architecture, process management, software metrics, entrepreneurship--that sort of thing. And so I've still never really had an academic foundation for a lot of the more theoretical stuff that those with bachelor's degrees in computer science have.

To clarify: I *do* know a lot of C.S. stuff in practice, because:

* I worked for two years at an algorithmic trading company, where performance was a key concern (use of optimal data structures was critical) and the software was highly concurrent (so I got plenty of hands-on experience with things like synchronization, mutexes, semaphores, etc.)
* I am a huge nerd who spends way too much time reading about skip lists and red-black trees and all that good stuff on Wikipedia

Anyway, all this is my long-winded way of introducing a little series of blog posts I'm going to be doing, starting with this one. The basic idea behind it should already be obvious: I'm going to "brush up" on (in some cases, learn entirely from scratch) some of the fun theoretical stuff that I missed by never going through a college C.S. program.