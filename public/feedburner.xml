<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"><channel><title>The Philosopher Developer</title><description>Dan Tao's blog, The Philosopher Developer</description><link>http://philosopherdeveloper.com/</link><item><title>Carousels, context, and judgment</title><link>http://philosopherdeveloper.com/posts/carousels-context-and-judgment.html</link><description><![CDATA[<p>I recently had a brief<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> online exchange with <a href="http://matthewcopeland.me/">Matt Copeland</a>, a former coworker at ThoughtWorks, about the website <a href="http://shouldiuseacarousel.com/">shouldiuseacarousel.com</a>. It’s a fun little site presenting several bullet points against the use of carousels (rotating banners) in website UIs<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>.</p>

<p>I’m no designer or UX expert. Over the years I’ve noticed that I <em>do</em> seem to take a greater interest in frontend-y stuff than most other developers I work with; but that’s a far cry from someone with expertise in user experience. Still, when Matt first posted a link to the carousel-bashing site I found myself responding skeptically. Of course, maybe that’s because I respond skeptically to pretty much everything that exists in this world.</p>

<p>Anyway, this shall be my attempt to explain my skepticism, concisely if I can (but knowing me, I probably can’t).</p>

<h2 id="judgments_require_context_1">Judgments require context</h2>

<p>Consider this point:</p>

<p class="plain"><img src="/images/point-without-context.png" alt="A point with no context"></p><p>A point with no context</p>

<p>Where is it? To answer that question we need some frame of <em>context</em>, or reference. For example, we could define a plane that the point lies in, with X and Y axes. Let’s do that:</p>

<p class="plain"><img src="/images/point-on-coordinate-system.png" alt="A point on a coordinate system"></p><p>A point on a coordinate system</p>

<p>Now we have context. The point is at <code>(5, 5)</code>.</p>

<h2 id="contexts_can_be_changed_2">Contexts can be changed</h2>

<p>But wait, is the point really at <code>(5, 5)</code>? Or is it just <em>somewhere</em>, and we overlaid a pair of axes on top of it? Clearly—in this case at least, since I’m the one writing this!–it’s the latter. We could just as easily draw the context like this:</p>

<p class="plain"><img src="/images/point-on-different-coordinate-system.png" alt="Same point, different coordinate system"></p><p>Same point, different coordinate system</p>

<p>Now the point is “at” <code>(100, 100)</code>.</p>

<p>The lesson here is that the context we bring to something affects how we measure it. This example was abstract, but the principle applies to all kinds of things.</p>

<p>Of course, we all know that already, right? Sure—but it’s easy to forget it, or to fail to recognize where it applies, especially when the “point” is something we feel strongly about.</p>

<h2 id="back_to_carousels_3">Back to carousels</h2>

<p>Whether carousels are generally “good” or “bad” isn’t a question I have any ambition to answer. If anything, if the UX community seems to have reached a consensus that they’re not good, I would tend to yield to that opinion. What I want to point out is simply that this is a case of bring-your-own-context, and that in such cases it’s necessary to acknowledge that fact before zeroing in on a judgment.</p>

<p>To be more specific: of the 6 references to information arguing against carousels on <a href="shouldiuseacarousel.com">shouldiuseacarousel.com</a>, 4 of them are explicitly about “clicking” or some other form of user interaction (such as a user performing a “task”<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>). I checked and one of the remaining 2 (<a href="http://www.widerfunnel.com/conversion-rate-optimization/rotating-offers-the-scourge-of-home-page-design">this article on the site WiderFunnel</a>) similarly appeals to carousels’ poor click-through performance. (The other reference I couldn’t track down in about 20 seconds of Google searching, so I didn’t bother. That’s at least 5 out of 6.)</p>

<p>The overall picture I get from this is that carousels are <strong>bad at generating clicks</strong>. This is the context, the frame of reference, that I guess a lot of designers must use in evaluating the effectiveness of some UI element. And maybe that’s fair, especially considering how much screen real estate carousels generally take up. (<em>If it isn’t driving clicks, did we really have to make it so big?</em>) But surely it isn’t the <em>only</em> possible metric by which we could make a judgment.</p>

<p>Personally, I found the anti-carousel argument arguments presented on the site a little odd at first. I’m not deeply involved in the world of UX, so maybe it’s because I haven’t internalized the same metrics by which most professionals in that world tend to judge interfaces. But I never thought of carousels as being a vehicle for interactive elements in the first place. I thought of them more as little slide shows, <strong>presenting content in a space-efficient way without requiring the user to scroll</strong>.</p>

<p>Here’s an example: <a href="http://www.regmovies.com/">the home page for Regal Cinemas</a> has a carousel showcasing some of the films that are currently playing in their theaters. This may be good or bad for a host of other reasons; again, I’m no expert. But I <em>do</em> think it would be wrong to assume that this particular carousel exists to generate clicks.</p>

<p><img src="/images/good-carousel.png" alt="The carousel on the Regal Cinemas home page"></p><p>The carousel on the Regal Cinemas home page</p>

<p>See, I actually think that this one makes sense. Yes, there are little interactive elements—links to buy tickets and view the trailer for each film—but they hardly seem like the focus here (as is evidenced by their tiny size and way-off-to-the-bottom-left positioning). I would guess that the implicit purpose of this carousel is simply to give the visitor a quick survey of what’s playing right now. To me, it serves that purpose well.</p>

<p>So this is a clear example of how the context you bring to something affects your judgment of that thing. We could judge carousels based on their click generation effectiveness, in which case they look pretty bad:</p>

<p class="plain"><img src="/images/click-generation-effectiveness.png" alt=""></p><p></p>

<p>But we could also judge them based on, say, information density (how much content is presented in a given area of the screen), in which case they would fare much better:</p>

<p class="plain"><img src="/images/information-density.png" alt=""></p><p></p>

<p>Keep in mind that I’m not saying information density is necessarily a worthwhile metric. Simply that it’s a <em>separate</em> one from click generation—I think that much is obvious—and so answering the question of how carousels measure up on that front requires a different set of questions.</p>

<h2 id="a_fixed_context_is_basically_dogma_4">A fixed context is basically dogma</h2>

<p>As I already said, I’m not here to argue that carousels are awesome. My example of information density is in fact probably a poor one, since I’m guessing most UX professionals would say that too much densely packed information is a bad thing. But if you at least agree that there are multiple ways to judge the elements of a user interface, then it should give you pause when someone says “Don’t ever use widgets because they’re bad at <em>X</em>.”</p>

<p><em>X</em> may be important. But it likely isn’t the only characteristic by which a widget should be judged. This attitude is analogous to taking the coordinate system from my first example, where the point lies at <code>(5, 5)</code>, and treating it as <em>fixed</em>, unaware that someone else could use a different system and interpret the point as somewhere else. A person with this mindset might think of the coordinates <code>(5, 5)</code> as being an <em>intrinsic property</em> of the point, and therefore view the point as inherently either “good” or “bad” based on that. To me, that’s pretty much the same thing as dogma: refusing to acknowledge the possibility of other contexts.</p>

<p>I realize that I’m getting a bit heavy-handed at this point, so I’m going to call it a day. I leave you with these words of wisdom:</p>

<blockquote>
<p>“Don’t ever use hammers. They’re really bad at driving screws.”</p>
</blockquote>
<div class="footnotes">
<hr>
<ol>
<li id="fn:1">
<p>As in, literally about 2 Tweets each. <a href="#fnref:1" rev="footnote">↩</a></p>
</li>
<li id="fn:2">
<p>Ironically, the site itself uses a carousel (to drive home the point, I guess). <a href="#fnref:2" rev="footnote">↩</a></p>
</li>
<li id="fn:3">
<p>And to my dismay, the “task” article about a user failing to recognize a deal displayed on a carousel, appears to be based on <em>a single user</em>. <strong>What?</strong> Are we really going to treat that as rigorous research? <a href="#fnref:3" rev="footnote">↩</a></p>
</li>
</ol>
</div>]]></description><pubDate>Tue, 06 Aug 2013 11:08:00 -0700</pubDate><guid>http://philosopherdeveloper.com/posts/carousels-context-and-judgment.html</guid></item><item><title>Problem obsession</title><link>http://philosopherdeveloper.com/posts/problem-obsession.html</link><description><![CDATA[<p>My last course as a grad student at CMU was <em>Entrepreneurship for Software Engineers</em>, in which teams of students basically worked on startup ideas for one semester, sharing their progress and collecting feedback during each class session and presenting to a small group of VC reps at the end of the term. I worked on a silly little app called <a href="http://www.instapie.net">InstaPie</a>–which I haven’t touched in months (mainly because I don’t have an Apple computer anymore!), though I <em>do</em> plan to pick it back up soon, I swear—and I remember during my presentation to the VCs, one of them asked, “What problem are you trying to solve here?”</p>

<p>This wasn’t my first exposure to the question, of course. We’d been taught to always keep this question in our crosshairs, to not lose sight of the goal. Identifying the problem and proposing a solution is an important part of any elevator pitch, I hear. If you can’t answer that question, then you’ve lost your way somehow. Start retracing your steps until you get back to the place where a problem is clear and what you’re working on actually solves it.</p>

<p>It makes sense; I won’t debate that. Nonetheless, I think this mentality is too fixed in our brains. We have <strong>problem obsession</strong>: always needing to fix something, solve something. Take something <em>problematic</em> and address that, rather than just pursuing an idea for its own sake.</p>

<p>I’m reminded of this whenever I hear people discussing things like space exploration or research into seemingly sci-fi notions like wormholes, or time travel, or <a href="http://www.npr.org/blogs/thetwo-way/2013/05/31/187581614/report-of-liquid-woolly-mammoth-blood-prompts-clone-talk">cloning a woolly mammoth</a>. There’s a very practical attitude some people have about this, which is: until we’ve solved all of our <em>actual</em> problems, happening right now, here on Earth, we should put those other things on hold. They’re not worth the resources, taxpayer money, etc. I don’t have a strong opinion about that, to be honest (the taxpayer money part—if private enterprise is the way forward for space travel, I won’t complain); but I do feel these things are important. Almost <em>more</em> important, in a way, than solving our problems.</p>

<p>Before you dismiss me as speaking nonsense, let me propose two possibilities.</p>

<p>First, let’s say that one day, hundreds or thousands of years in the future, we’ve solved all of our problems. No more crime, hunger, sickness, any of that stuff. The whole human race is living prosperously and peacefully. Then what? Do we have nothing to do anymore? Of course not: hopefully, in a world like that, we’d all be artists and scientists: creating and discovering things, just because. In which case, the whole point of solving problems was presumably to <em>get</em> to that point.</p>

<p>That’s not very realistic, if you ask me; so here’s the second possibility. We <em>never</em> solve all of our problems. That is, there will always be something “wrong” that needs to be addressed. What then? Are we going to perpetually work on solving problems when the work will never be done? Well, <em>yes</em>, actually; but is that <em>all we’re going to do</em>, to the exclusion of all other things? Seems a bit like <a href="https://en.wikipedia.org/wiki/Sisyphus">Sisyphus</a>, doesn’t it?</p>

<p>In either of these scenarios, I think we’re better off not diverting 100% of our attention to the mere solving of problems. It would not be a very gratifying existence. In the first case it ends up that we’re just getting the rough part out of the way, setting up some distant future generation for a <em>truly</em> good life while we toil away in the present. (As noble as that may sound, it still undermines the <em>inherent</em> value of solving problems as more than just a means to an end.) And in the second case we’re devoting all of our energy to what is ultimately just maintenance: perpetually chipping away at an issue that’s never going to be fully resolved.</p>

<p>Of course, I’m not saying that we should forget about solving real problems and turn all of our attention to purely creative or theoretical work. That would be a mistake. Really it comes down to this: solving problems should not be the <em>only</em> thing we think about. Problems are important, and we need people in this world to be working on them. But not <em>every</em> person.</p>

<p>Circling back to my experience in the entrepreneurship class at CMU: I think this all struck me with particular force hearing that question from a VC investor. Because there’s undoubtedly a lot of awesome innovation happening in Silicon Valley, the Bay Area, and all around the world’s other tech centers. But there are also a lot of “problems” getting solved here that maybe aren’t really so important, and I blame problem obsession. Maybe we can actually spare a few heads on “It’s hard to get a taxi in San Francisco!” and “We’re going to turn the restaurant reservation system on its head!” I, for one, would like to see a higher percentage of the talented people in this world making things that are just intriguing, or beautiful, or fun. For its own sake.</p>]]></description><pubDate>Thu, 11 Jul 2013 09:21:00 -0700</pubDate><guid>http://philosopherdeveloper.com/posts/problem-obsession.html</guid></item><item><title>Hero culture vs. Borg culture</title><link>http://philosopherdeveloper.com/posts/hero-culture-vs-borg-culture.html</link><description><![CDATA[<p>Most of us in software (and probably in other fields) know about <strong>hero culture</strong>. It’s a concept everybody loves to hate. The term refers to an environment where individuals work in isolation and thrive on receiving sole credit for their work. This is generally perceived as leading to inflated egos and poor cooperation among developers. It’s the same phenomenon you see in professional sports, when star athletes are sometimes accused of not being good “team players” and getting greedy with the ball, wanting to be the center of attention.</p>

<p>So there are social reasons to dislike hero culture. There are plenty of practical reasons, too. One involves a principle known as the <a href="http://en.wikipedia.org/wiki/Bus_factor">bus factor</a>: the more you rely on a hero, the more vulnerable you are in the event of losing him or her—e.g., if he or she is hit by a bus, or leaves for another company.</p>

<p>But you guys know me. If everybody else is going left, I’m going to go right (a highly predictable trait that <a href="http://www.skalb.com/">my friend Sameer</a> frequently reminds me of).</p>

<p>If you turn away from hero culture and sprint in the opposite direction, you’ll eventually start getting into what I’ll call <strong>Borg culture</strong>.</p>

<p>Borg culture is the antithesis of hero culture, where every individual is functionally equivalent. In a Borg culture, there is no place for glory or arrogance. There’s also no pride and no personal ownership. I would argue that this isn’t really better.</p>

<p>A while back I wrote about <a href="/posts/am-i-an-engineer.html">software engineering versus software craftsmanship</a>. In general, I think most of us would associate my description of “engineering” with what is typically done at larger corporations—less personal, more mechanical. That sounds like Borg culture. Actually, I think it’s just the opposite. Big companies are notoriously conducive to hero culture, because they have a tendency to become large and bloated, teeming with mediocrity. This encourages better-than-average individuals to rise above the fray and get a lot of recognition for not being mediocre.</p>

<p>I suspect many of us have been in that situation at least once or twice. It can be a nice feeling, to have everyone impressed with you for something that really wasn’t so hard. It’s a dangerous place to be in, though, because after a while you get comfortable and stop improving. Without data to back it up, I nonetheless feel confident in saying that this happens all the time to “engineers” at big companies.</p>

<p>Counterintuitively, I see those who fall much closer to the “craftsman” end of the spectrum often succumb to the allure of Borg culture. On first glance that doesn’t seem like it would be right. But it is, in my experience, for at least two reasons:</p>

<ol>
<li>A craftsman (in my personal, egregiously over-generalized opinion) is more humble. He is likely to reject labels like “hero” or “rock star” (ugh!) and downplay his own talents.</li>

<li>Craftsmen put a lot of stock in practices that de-emphasize <em>personal</em> awesomeness: pair programming, TDD, CI, etc. These so-called agile methods embrace the inevitability of mistakes and focus on solving problems iteratively. There is a humility to this mindset as well.</li>
</ol><p>Some of the outcomes of Borg culture are commonly viewed in a positive light, but I believe it would be wise to consider them more critically. One example is <strong>collective code ownership</strong>. Agile teams often sing the praises of this idea that we’re all responsible for all of the code. That can be a great thing, inasmuch as it encourages each of us to follow the <a href="http://programmer.97things.oreilly.com/wiki/index.php/The_Boy_Scout_Rule">Boy Scout Rule</a> and happily fix one another’s bugs. It can also be problematic.</p>

<h2 id="a_borg_culture_anecdote_1">A Borg culture anecdote</h2>

<p>On my last project at ThoughtWorks, I was pairing with our team’s tech lead on a pretty important piece of our project’s overall architecture. We set out to lay the groundwork for what would eventually become a public API. One of the decisions we made early on as a team was to be very disciplined about dogfooding our own API, building a front end that would operate as an ordinary client, with no special privileges. We didn’t want to go the standard website approach where your logic ends up being tightly coupled to your views. Everybody was more or less on board with this plan.</p>

<p>We did a bit of work, but didn’t get all that much done before it was time to rotate pairs. (Another decision we had made as a team was to regularly rotate pairs, to maximize knowledge transfer among devs and get everybody exposed to everything. The project was an iPad app, with a Ruby back end as well as a mobile web UI. So we were all writing Objective-C, Ruby, and CoffeeScript—a great learning experience for most of us!<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>)</p>

<p>One of us—I can’t remember who—stayed on the same story and worked alongside another dev. Some time later, the pairs rotated again. It turned out that this work took place over the course of several rotations. By the end, the two developers working on the story were quite far removed from the conversations we originally had about it. Context was lost, and it was a bit of a mess: the coupling we had hoped to avoid was quite strong, and the API was not shaping up at all.</p>

<p>This wasn’t supposed to happen! The whole point of rotating pairs and having everybody work on everything was to ensure that context <em>not</em> be lost. What went wrong?</p>

<p>In retrospect, recognizing that things had been going badly, the team acknowledged that we should have bent the rules with respect to pair rotation on this particular story. Looking back on the situation now, though, I think what happened is not so surprising. It comes back to what I said earlier about Borg culture: taken too far, it can cause a team to be deficient in personal pride and individual ownership. Then <a href="http://en.wikipedia.org/wiki/Broken_windows_theory">broken window theory</a> sets in: since the code is <em>everyone’s</em> responsibility, everybody thinks “surely someone else is keeping an eye on this.” It might as well be <em>no one’s</em> responsibility.</p>

<h2 id="specialization_is_inevitable_2">Specialization is inevitable</h2>

<p>Collective ownership is a great idea, but it has its limits. On large projects, it can be unrealistic. Imagine a small community where everyone knows each other and there’s a neighborhood watch. That sounds about right. If you tried to apply the same idea to a larger city it wouldn’t hold. A person can’t deeply, personally care about every street corner in a metropolis. So specialization needs to happen.</p>

<p>I actually left ThoughtWorks before the project was completed. Around that time, the team was discussing the idea of splitting into specialized groups: one for the iOS app, one for the back end, one for the mobile web UI—or anyway, something like that. We had been tossing the idea around for a while, but none of us really <em>wanted</em> to do that. Over time, however, it was becoming clear that it was probably the right thing to do. We needed ourselves to take more ownership in what we were doing; and if it that wasn’t happening on its own, we needed to <a href="/posts/automating-yourself.html">program ourselves</a> to <em>make</em> it happen.</p>

<p>When you make people responsible for something, they tend to rise to the occasion. This is the real reason I think we need to shake up our biases, just a little bit, when it comes to hero culture. Of course, if we were to head back in that direction we wouldn’t want to call it “hero culture” but something less self-congratulatory. No one wants to foster a team filled with arrogance. But we also don’t want a scenario where there’s no coherent vision and nobody takes personal responsibility for anything, right?</p>

<p>So as it seems I’m always saying, aim for the middle. Hero culture has its fair share of problems, but so does Borg culture. Let’s not throw the baby out with the bathwater; personal ownership and accountability are actually <em>good</em> aspects of hero culture. And collaboration and humility are terrific aspects of Borg culture. Take the good from each, and try to avoid becoming so proud or so dogmatic that you start inheriting the bad.</p>
<div class="footnotes">
<hr>
<ol><li id="fn:1">
<p>FYI, you might start seeing more exclamation points from me in the immediate future. I just finished reading <a href="http://www.amazon.com/Surely-Feynman-Adventures-Curious-Character/dp/0393316041"><em>Surely you’re joking, Mr. Feynman!</em></a> and loved it! (Feynman makes liberal use of exclamation points. My high school English teacher would not have approved.) <a href="#fnref:1" rev="footnote">↩</a></p>
</li></ol>
</div>]]></description><pubDate>Fri, 14 Jun 2013 08:30:00 -0700</pubDate><guid>http://philosopherdeveloper.com/posts/hero-culture-vs-borg-culture.html</guid></item><item><title>Introducing Lazy.js</title><link>http://philosopherdeveloper.com/posts/introducing-lazy-js.html</link><description><![CDATA[<p>I recently started a JavaScript project called <strong>Lazy.js</strong> that’s been getting quite a lot of attention<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>. Essentially the project is a utility library in a similar vein to <a href="http://underscorejs.org/">Underscore</a> or <a href="http://lodash.com/">Lo-Dash</a>, but with <a href="http://en.wikipedia.org/wiki/Lazy_evaluation">lazy evaluation</a> (hence the name).</p>

<p>The reason I think the project has been piquing the interest of so many JavaScript developers is that it offers the promise of some truly solid performance, even compared to Lo-Dash (which is itself highly optimized in comparison to Underscore). This chart shows the performance of Lazy.js compared to both of those libraries for several common operations on arrays of 10 elements each on Chrome:</p>

<p class="plain"><img src="/images/lazy-performance.png" alt="Lazy.js performance versus Underscore and Lo-Dash"></p><p>Lazy.js performance versus Underscore and Lo-Dash</p>

<p>You can read more about what Lazy.js <em>does</em> <a href="http://dtao.github.io/lazy.js/">on the project website</a> or in the README <a href="https://github.com/dtao/lazy.js">on its GitHub page</a>. In this blog post, I want to write a little bit about how it <em>works</em>, and what makes it different.</p>

<h2 id="a_different_paradigm_1">A different paradigm</h2>

<p>Fundamentally, Lazy.js represents a paradigm shift from the model of Underscore and Lo-Dash (starting now I’m just going to say “Underscore” for brevity), which provide a host of useful functions for what I’ll call <strong>array transformation</strong><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>: each function accepts an array as input, does something with it, and then gives back a new array:</p>

<p class="plain"><img src="/images/array-transformation.png" alt="Array transformation"></p><p>Array transformation</p>

<p>This isn’t how Lazy.js works. Instead, what is essentially happening at the core of Lazy.js is <strong>function composition</strong>: each function accepts a <em>function</em> as input, stores it, and gives back an object that can do the same. Then ultimately when <code>each(fn)</code> is called on the last object in the chain, it composes all of those functions together, effectively changing the behavior of <code>fn</code>.</p>

<p>Let’s take <code>map</code> as an example. The idea of <em>mapping</em> is simple and something we do all the time; it basically means <em>translating</em> or <em>converting</em>.</p>

<p>Here’s some code that uses <code>map</code> from Underscore:</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">array1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
<span class="kd">var</span> <span class="nx">array2</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">array1</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">array1</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="p">});</span>
</pre></div>

<p>In the above snippet, <code>array1</code> is <em>mapped</em> to <code>array2</code> using a function that shifts each value up by five. The process involves three significant parts:</p>

<ol>
<li>Look at every element in the array</li>

<li>Apply the mapping function on it</li>

<li>Store the result in a new array</li>
</ol><p>This 3-step process is a core part of Underscore’s paradigm: again, arrays go in, arrays come out. With Lazy.js, parts 1 and 3 above are not a core part of the paradigm. You can get the equivalent of step 1 with <code>each</code>, and you can get the equivalent of step 3 with <code>toArray</code>; but you’re not <em>required</em> to do either of those things.</p>

<p>To illustrate what I mean, let’s look at the <code>map</code> example again, this time using Lazy.js.</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">array</span>    <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
<span class="kd">var</span> <span class="nx">sequence</span> <span class="o">=</span> <span class="nx">Lazy</span><span class="p">(</span><span class="nx">array</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">array</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="p">});</span>
</pre></div>

<p>Remember that <code>sequence</code> above is not an array; none of the elements of <code>array</code> has been accessed at this point. Which means we can do this:</p>

<div class="highlight"><pre><span class="c1">// Result: 8</span>
<span class="kd">var</span> <span class="nx">middle</span> <span class="o">=</span> <span class="nx">sequence</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</pre></div>

<p>…and dive straight into the middle of the sequence without iterating. This is what I meant by saying step 1 from Underscore’s paradigm is not a core part of Lazy.js.</p>

<p>Similarly, we can do this:</p>

<div class="highlight"><pre><span class="cm">/* Output:</span>
<span class="cm"> * 6</span>
<span class="cm"> * 7</span>
<span class="cm"> * 8</span>
<span class="cm"> * 9</span>
<span class="cm"> * 10</span>
<span class="cm"> */</span>
<span class="nx">sequence</span><span class="p">.</span><span class="nx">each</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="p">});</span>
</pre></div>

<p>…and, <em>without creating any extra array</em>, we’ve viewed the results. This is why I said Underscore’s step 3 (storing results in a new array) is also not a core part of Lazy.js.</p>

<h2 id="digging_a_bit_deeper_2">Digging a bit deeper</h2>

<p>So I’ve said what makes Lazy.js different from Underscore, but I haven’t really explained how it works in much depth.</p>

<p>I did mention function composition. Let’s take a look at a concrete example to make that a bit clearer.</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">array</span> <span class="o">=</span> <span class="nx">Lazy</span><span class="p">.</span><span class="nx">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">).</span><span class="nx">toArray</span><span class="p">();</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"First 10 squares that are evenly divisible by of 3:"</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">sequence</span> <span class="o">=</span> <span class="nx">Lazy</span><span class="p">(</span><span class="nx">array</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span><span class="p">;</span> <span class="p">})</span>
  <span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">===</span> <span class="mi">0</span><span class="p">;</span> <span class="p">})</span>
  <span class="p">.</span><span class="nx">take</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">each</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="p">});</span>
</pre></div>

<p>Maybe that’s a bit noisy—I just wanted to have a full example program—so I’ll focus on just the <code>map</code>, <code>filter</code>, and <code>take</code> parts.</p>

<p>As I said earlier, each function in Lazy.js accepts another function and then creates an object to store it. So the result of <code>map</code> is an object—a <code>MappedSequence</code>–that stores its argument and exposes the same API as the object originally returned by <code>Lazy(array)</code>.</p>

<pre><code>MappedSequence(mapFn)</code></pre>

<p>This object is then the “parent” of any objects <em>it</em> creates. The result of <code>filter</code>, then—a <code>FilteredSequence</code>–holds a reference to the mapped sequence as well as its filtering function:</p>

<pre><code>MappedSequence(mapFn)
  FilteredSequence(filterFn)</code></pre>

<p>Next we have <code>take</code>, which creates a <code>TakeSequence</code> that stores the count we pass to it:</p>

<pre><code>MappedSequence(mapFn)
  FilteredSequence(filterFn)
    TakeSequence(count)</code></pre>

<p>Finally, when <code>each</code> is called, we compose everything together. In this example, the data underlying our nested sequences is an array; so <code>each(fn)</code> does just what you’d think: iterates over the source array, and…</p>

<ul>
<li>feeds each element to <code>mapFn</code>,</li>

<li>feeds the result of <code>mapFn</code> into <code>filterFn</code>,</li>

<li>feeds those elements with truthy results from <code>filterFn</code> to the <code>TakeSequence</code>, which…</li>

<li>feeds the first 10 results to <code>fn</code>, then ends the iteration (by returning <code>false</code>)</li>
</ul><p>Another way of looking at it is this. Let’s forget about arrays (or collections, or sequences) entirely for a moment. The core idea behind <code>map</code> is, as I said, <em>translation</em>. This is independent of the idea of iteration. It’s simply the idea of, for some value, mapping it to another value.</p>

<p>Same with <code>filter</code>: it doesn’t necessarily have to do with iteration. The idea of filtering is, for some value, testing whether it satisfies some condition or not.</p>

<p>And so, if we don’t think about arrays at all, we can still combine these concepts. For some value <em>x</em>, we can <em>map</em> it to <em>y</em>, and then we can <em>filter</em> that <em>y</em> to check whether it satisfies a condition.</p>

<pre><code>// Looks like function composition to me!
filter(map(x))</code></pre>

<p>As a pure replacement for Underscore—which it can be—Lazy.js is basically an inversion of the 3-step process I described. Instead of doing 1-2-3, 1-2-3, &amp;c. for each operation, we can do 1 (for each element in the source…), then <em>all 2s combined</em> (every <code>map</code>, <code>filter</code>, etc. composed together), and finally 3 (store the results in a new array). You don’t <em>need</em> to use Lazy.js that way—as I hopefully have emphasized quite enough by now!–but you can, if you’re just looking for a drop-in Underscore replacement. And that wouldn’t be a bad call, given the performance difference!</p>

<p>The reason I keep saying that isn’t all that Lazy.js is about, though, is that there’s a lot more you can do as a result of this different model. You can generate indefinite sequences, iterate asynchronously, map/reduce on DOM events (or any event type, really), lazily split strings, and more. Take a look at <a href="http://dtao.github.io/lazy.js">the Lazy.js website</a> or—better yet—actually <a href="https://github.com/dtao/lazy.js">give Lazy.js a try</a> and see for yourself what else you can do.</p>

<h2 id="the_road_ahead_3">The road ahead</h2>

<p>Thus far this project has received a much more enthusiastic response than I would’ve predicted, which is a bit daunting. That said, I’m not sure it’s actually being used much out in the wild yet. I only just recently <a href="https://npmjs.org/package/lazy.js">published it as a Node package</a>; and while I’ve started working on documenting the code properly, I haven’t quite settled on an approach yet. (In other words, the documentation is quite lacking at the moment.) Even the organization of the repository (names of folders, which files go where, etc.) is something I haven’t really ironed out. So a lot is in flux.</p>

<p>That said, it would make me really happy if people start trying out Lazy.js for real and <a href="https://github.com/dtao/lazy.js/issues">submitting issues</a> to help me find bugs faster and prioritize working on the most useful real-world features.</p>

<p>I also attribute some of the library’s sudden popularity to <a href="http://dtao.github.io/lazy.js/">the project website</a>, which includes a nice benchmark runner to compare Lazy.js against <a href="http://dtao.github.io/lazy.js/comparisons.html">several other libraries</a> and view the results in an intuitive and visually appealing format. In the back of my mind I’m planning to eventually refactor some code out of there and into another open source project specifically geared towards comparing the performance of competing libraries, or even standalone functions.</p>

<p>For now, though, I’ll keep working on Lazy.js and hoping to get some feedback from users.</p>
<div class="footnotes">
<hr>
<ol>
<li id="fn:1">
<p>For me, anyway—as of the time I’m writing this, it has <a href="https://github.com/dtao/lazy.js">865 stars on GitHub</a>! <a href="#fnref:1" rev="footnote">↩</a></p>
</li>
<li id="fn:2">
<p>I <a href="/posts/brushing-up-on-cs-part-1-algorithmic-complexity.html">don’t have a C.S. background</a>, so I don’t know if there’s a academic term for these ideas. Probably is. <a href="#fnref:2" rev="footnote">↩</a></p>
</li>
</ol>
</div>]]></description><pubDate>Fri, 31 May 2013 11:12:00 -0700</pubDate><guid>http://philosopherdeveloper.com/posts/introducing-lazy-js.html</guid></item><item><title>Rethinking priority</title><link>http://philosopherdeveloper.com/posts/rethinking-priority.html</link><description><![CDATA[<p>Looking back on some of my recent posts on this blog, I’m a bit annoyed at myself for being too hand-wavy and not saying anything all that original.</p>

<p>I’d like to make an effort, at least in my next few posts, to get more concrete and challenge some of the conventions I’ve observed in the software world. I’ll start with an idea that I think is not all that radical, though it <em>would</em> mark a sigificant departure for most teams I’ve worked on.</p>

<h2 id="how_we_think_about_priority_1">How we think about priority</h2>

<p>The way most teams prioritize work seems totally sensible on the surface. Essentially, tasks are assigned some priority ranking such as “high”, “medium” or “low”; and then the highest-ranked tasks actually get assigned to people. In a perfect world this would mean that the most important things always get done, and then when there’s a surplus of time a team can “catch up” on issues that aren’t quite as urgent. In practice I think a different reality tends to emerge.</p>
<iframe src="http://charter.herokuapp.com/embed/G8G85MQY" style="height: 450px; width: 600px;"></iframe>
<p>On projects I’ve been a part of, inevitably it turns out that the “high-priority” work is the <em>only</em> work that gets done. We never seem to run out of high-priority things to do; and so there ends up being <strong>this giant mountain of “low-priority” issues</strong> that, if we’re honest with ourselves, will never be tackled. Which would imply that more and more important things keep always coming up.</p>
<iframe src="http://charter.herokuapp.com/embed/K8IUBCNI" style="height: 450px; width: 600px;"></iframe>
<p>But either this isn’t true, or it shouldn’t be.</p>

<p>Other than the fact that it just doesn’t seem reasonable that such a curve could actually represent reality, I see two problems here. First, the accumulation of many small bugs over the life of a project brings the quality of the software down, which is a sad state of affairs. Have you ever encountered a bug for the 100th time in some application you use regularly, and suddenly it occurred to you that that bug has been around <em>forever</em>? The other problem, which is arguably even worse, is the technical debt that so many low-priority defects represent. Choosing to always plow forward with high-priority items while allowing all these little problems to pile up exerts drag on a team. It becomes harder to make forward progress.</p>

<p>Just as there are two major problems, there are at least two mistakes that lead to this predicament. The first is a classic one that most of us are at least subconsciously already aware of, which is that we get too fixated on <em>adding features</em> to software when there are still minor issues to resolve. Quite simply, fixing bugs isn’t sexy. And so we move towards buggy, bloated software with too many features instead of high-quality software with just the right features.</p>

<p>The other mistake is more psychological. I can’t really prove this, but it’s my hypothesis that on strictly priority-based projects our minds come to think of <em>priority</em> as <em>likelihood of actually getting done</em>. Which makes sense, because the two end up being perfectly correlated. We therefore <strong>tend to over-prioritize new work that we’re excited about</strong> out of fear that it just won’t get done otherwise. And the cascading effect of this is that bugs we’ve been meaning to fix and little improvements we’ve been meaning to make get neglected over and over again.</p>

<h2 id="how_we_could_do_it_differently_2">How we could do it differently</h2>

<p>Here’s a different approach I would like to try some day. Instead of adopting the mindset that we will always work on high-priority items—logical though that may be in theory—what if we allocated our time <strong>in advance</strong> on a weighted basis, so that high-priority items get the most time but medium- and/or low-priority work gets some time as well? For example, we might say that out of every two weeks (10 working days), “high-priority” work gets 7 days, “medium” work gets 2, and “low” gets 1<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>.</p>
<iframe src="http://charter.herokuapp.com/embed/NBSU8ZSB" style="height: 450px; width: 600px;"></iframe>
<p>Why take this approach? I acknowledge that it seems a bit counterintuitive to <em>force</em> work on lower-priority tasks, when there’s theoretically more important work to do. But I actually think this would get us closer to an ideal distribution of work than where most of us currently are. Instead of the mildly <a href="http://en.wikipedia.org/wiki/ADD">ADD</a> pattern of working on whatever seems important right now, and perpetually “forgetting” to do less-urgent work, a fixed allocation would nudge us back in the direction of refactoring, fixing bugs, and actually implementing some of those nice-to-haves we never seem to implement.</p>

<p>More importantly, I think this strategy would allow us to be more honest with ourselves. The truth is that “high-priority” often doesn’t really mean high priority: it’s a stand-in for <em>probability of happening</em> (the psychological mistake I mentioned). Knowing that so-called “low priority” work <em>is</em> going to get done—that it <em>won’t</em> just get swept under the rug—might enable us to make more truthful decisions about what we should be spending the lion’s share of our time on.</p>

<p>What do you think?</p>
<div class="footnotes">
<hr>
<ol><li id="fn:1">
<p>I’m just throwing these numbers out there. I would expect any team who attempted something like this to revisit the breakdown periodically in the beginning—say, every couple of months—to calibrate and figure out what works best. <a href="#fnref:1" rev="footnote">↩</a></p>
</li></ol>
</div>]]></description><pubDate>Sat, 27 Apr 2013 14:17:00 -0700</pubDate><guid>http://philosopherdeveloper.com/posts/rethinking-priority.html</guid></item><item><title>In defense of global state</title><link>http://philosopherdeveloper.com/posts/in-defense-of-global-state.html</link><description><![CDATA[<p>I bet you weren’t expecting any sane developer to make this argument!</p>

<p>Well, to be fair, the title of this post is somewhat intentionally provocative<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>. But anyway, you’re here now; so it served its purpose. And make no mistake: I <em>am</em> going to defend global state—just possibly not in quite the way you might be expecting.</p>

<h2 id="what_we_mean_by_global_state_1">What we mean by global state</h2>

<p>First, some background. If you’re reading this, there’s a good chance you’re a developer so I probably don’t have to explain this; but I think there are at least two forms of <strong>global state</strong> that come to mind in software. One form is global <strong>variables</strong>–values that are accessible and can be changed, globally, anywhere, by all of the code in a project. The other is <strong>constants</strong>–values that may be <em>accessible</em> to potentially every part of a program, but cannot be changed.</p>

<p>These aren’t the only kinds of global state, though. I would argue that <em>globality</em>–apparently that’s <a href="http://dictionary.reference.com/browse/globality">actually a word</a><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>–is a <em>continuous</em> (as opposed to discrete or binary) property. Meaning: it isn’t just variables and constants; there are things in between as well. There are some values that will <em>definitely</em> change (e.g., a global cache), there are some that <em>might</em> (e.g., a feature flag), others that probably won’t (static configuration values), and so on. There is also the question of a variable’s <em>impact</em>, which is not the same as its <em>scope</em>, or how widely it happens to be accessible. One bit of state might define the language or dialect in which an entire UI is presented, for example, while another may simply indicate whether or not to display a certain dialog when an application loads.</p>

<p>So there’s some sort of spectrum here (you know <a href="/posts/am-i-an-engineer.html">how I like spectrums</a>), or at the very least there’s more than just one or two kinds of global state.</p>

<h2 id="whats_wrong_with_global_state_2">What’s wrong with global state?</h2>

<p>Global state has got a pretty bad rap in most of the software development community. For one, use of global state can make it difficult to reason about a section of code: what’s happening <em>locally</em> may be clear, but the far-reaching <em>ramifications</em> of the code probably aren’t. Global state also tends to fuel the proliferation of implicit dependencies between software components, making it increasingly difficult to “pull apart” those components down the line and resulting in code that less testable and less reusable.</p>

<p>There are plenty more reasons. I’m not going to claim they’re invalid. But a recent tweet by my old teammate <a href="http://scottmuc.com/">Scott Muc</a> got me thinking on this topic, and it compelled me to consider the dissenting opinion<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>.</p>
<blockquote class="twitter-tweet">
<p>Sometimes convention based frameworks feel like it's just 0 param methods using hidden global variables.</p>— Scott Muc (@ScottMuc) <a href="https://twitter.com/ScottMuc/status/326481455804997632">April 22, 2013</a>
</blockquote><p>Embedded in Scott’s statement is the shared understanding that global variables are A Bad Thing<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>. When everyone takes that for granted, then you can say things like “blah blah blah global variables” and your audience will intuitively grasp that <em>global variables</em> is just a proxy for <em>something bad</em>. Similarly, if I said, “Feature X is the <code>goto</code> of Language Y,” you would understand I’m saying <a href="http://www.u.arizona.edu/~rubinson/copyright_violations/Go_To_Considered_Harmful.html">something bad about Feature X</a>.</p>

<p>Now, regarding the kinds of global state I described earlier: I would guess that most of us are much more sympathetic to <em>constants</em> than to global <em>variables</em>. Constants, at least don’t cause the same action-at-a-distance confusion that variables can. However, they still exhibit the other drawback I mentioned of global state: that dependence may spread through a code base, inhibiting reusability.</p>

<p>So we like constants more than global variables, but we’re not exactly thrilled about either of them. What does this imply about the spectrum of globality? Do we start at “good” and gradually move towards “bad” the more scope and impact some bit of global state has?</p>

<p>More to the point: if I acknowledge the drawbacks of global state, why do I also like convention-based frameworks? What might I disagree with about Scott’s tweet?<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup></p>

<h2 id="deciding_what_should_be_global_3">Deciding what should be global</h2>

<p>I think the real question with global state comes down to considering a section of code, and deciding <em>what should be flexible</em>. That may sound obvious on one hand—variables are things that change, so we use variables where we want to allow flexibility—but on the other, I suspect the idea of making this decision feels somewhat foreign to lots of developers. Many of us have come to accept, almost without thinking, that flexibility is an inherent good. Invariant, inflexible aspects of a software system are perceived as weaknesses or poor design. Flexibility, modularity, reusability: these are all sort of rolled up into one big bundle of attributes we automatically ascribe to any “good” or “well-written” software.</p>

<p>But fundamentally, we human beings are limited in our mental capacity. Infinitely flexible systems are not in our best interest, for the simple reason that flexibility demands our attention<sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup>. And so choosing the scope of a variable is really a matter of deciding <strong>at what point some information should require our attention</strong>, and at what point we should be able to take it for granted.</p>

<p>There’s a great section of <a href="http://www.amazon.com/G%C3%B6del-Escher-Bach-Eternal-Golden/dp/0465026567/">Gödel, Escher, Bach</a> by Douglas Hofstadter that I think captures this idea quite beautifully. It is a chapter in which some characters tinker with a magical TV set that can alter the reality of a football game they’re watching. By turning some knobs, they can see players alternately catching the ball or fumbling, scoring a touchdown or getting blocked, etc. One character fiddles with the knobs very aggressively and the game changes much more dramatically, to everyone’s surprise.</p>

<p>Hofstadter goes on to compare the functioning of these knobs on the TV to “constants,” “parameters,” and “variables”–terms that should be quite familiar to any software developer:</p>

<blockquote>
<p>We build up our mental representation of a situation layer by layer. The lowest layer establishes the deepest aspect of the context—sometimes being so low that it cannot vary at all. For instance, the three-dimensionality of our world is so ingrained that most of us never would imagine letting it slip mentally. It is a constant constant. Then there are layers which establish temporarily, though not permanently, fixed aspects of situations, which could be called background assumptions—things which, in the back of your mind, you know can vary, but which most of the time you unquestioningly accept as unchanging aspects. These could still be called “constants”. For instance, when you go to a football game, the rules of the game are constants of that sort. Then there are “parameters”: you think of them as more variable, but you temporarily hold them constant. At a football game, parameters might include the weather, the opposing team, and so forth. There could be—and probably are—several layers of parameters. Finally, we reach the “shakiest” aspects of your mental representation of the situation—the variables. These are things such as [a player] stepping out of bounds, which are mentally “loose” and which you don’t mind letting slip away from their real values, for a short moment.</p>
</blockquote>

<p>Really, I probably could have skipped everything I’ve written so far and just started with that Hofstadter quote. But what’s done is done, so let’s move on now.</p>

<h2 id="the_relationship_between_explicit_and_global_4">The relationship between explicit and global</h2>

<p>It’s very common for developers coming from more “conventional” backgrounds (har har) to be initially perplexed by the “magic”<sup id="fnref:7"><a href="#fn:7" rel="footnote">7</a></sup> of convention-based frameworks such as <a href="http://rubyonrails.org/">Rails</a>. This is a natural reaction for many of us with previous experience working on <a href="http://en.wikipedia.org/wiki/Big_ball_of_mud">big balls of mud</a>, with enough global state to give us nightmares. But when you consider the opposite approach—explicit configuration at every level—I think what you’ll find is a lot of boilerplate<sup id="fnref:8"><a href="#fn:8" rel="footnote">8</a></sup> and an indefensible number of <a href="http://www.xprogramming.com/Practices/PracNotNeed.html">YAGNI</a> violations.</p>

<p>Which brings me to an objection I’ve been sensing through the ether while writing this. Somewhere out there, one of you is yelling at the screen: <em>Global values and implicit values are not the same thing!</em> If it seems to you that I’ve been conflating the ideas of “global state” with “hidden information” until now, that’s probably fair. But now chew on this for a second: <strong>the more global something is, the less explicit it should have to be</strong>.</p>

<p>Here’s one of probably millions of examples I could give: when you walk up to someone in the U.S., I’m guessing you don’t start the conversation by asking, “Do you speak English?” The vast majority of people here speak English—it is effectively a <em>global value</em> in our country—which means we can be <em>implicit</em> in that knowledge when we interact. It saves time, and removes one potential variable of consideration–<em>What language(s) does this individual speak?</em>–from our minds, reducing cognitive load.</p>

<h2 id="the_pitfalls_of_always_being_explicit_5">The pitfalls of always being explicit</h2>

<p>Of course, implicitly understood global state unavoidably involves a learning curve. There is no way you can just walk into a foreign culture and expect to internally understand that culture without making a serious time investment, for example. But we all know that. It’s why <a href="http://en.wikipedia.org/wiki/Language_immersion">language immersion</a> is widely accepted (last I checked) as by far the most effective way to become fluent in a natural language.</p>

<p>Imagine someone from another culture who “masters” English, perfectly grasping the vocabulary and all of the grammatical rules of the language, then visits the United States and becomes frustrated by all of our idioms (“beat a dead horse”, “break a leg”, etc.), cultural references (“good thinking, Sherlock”), and other random phrases whose meanings aren’t obvious at the surface level. To such a person I’d say: “Look, it just takes time.” That’s the cost of really learning the language.</p>

<p>But let’s take a step back and imagine what life would be like if we insisted on being explicit about everything instead. I might have an exchange like this with a coworker:</p>

<blockquote>
<p>Coworker: How’s Kathryn doing?<br>Me: Which Kathryn? <em>[Kathryn is my wife’s name.]</em></p>
</blockquote>

<p>Or you might have this odd encounter with a stranger on the sidewalk:</p>

<blockquote>
<p>You: What time is it?<br>Stranger: In which time zone?</p>
</blockquote>

<p>A doctor might be vexed by an overly-explicit patient:</p>

<blockquote>
<p>Doctor: How much do you weigh?<br>Patient: On which planet?</p>
</blockquote>

<p>These things are what Hofstadter called “constants”; we may be able to <em>imagine</em> them changing—in some cases much more readily than others (e.g., changing time zones vs. changing planets)–but, generally speaking, we expect them not to. At the very least, they’re certainly not going to change mid-conversation.</p>

<p>More importantly, there are <em>very sensible defaults</em> for the “ambiguous” values in these examples. If someone refers to “Kathryn” in a conversation with me, he or she is almost certainly referring to the Kathryn most important to me: my wife. If you ask someone what time it is, you’re very likely asking about the time zone where you currently are. And in almost <em>every</em> conversation, when referring to properties of objects, we’re specifically talking about how things are on Earth. All of this can remain <em>implicit</em>; we don’t have to think about these things at all.</p>

<h2 id="hidden_global_variables_can_be_our_friends_6">Hidden global variables can be our friends</h2>

<p>I believe many of us have been trained to be overly explicit in developing software, preferring dependency injection and local configuration at every level of depth throughout a system. The classic example, which has <a href="http://david.heinemeierhansson.com/2012/dependency-injection-is-not-a-virtue.html">received some criticism</a>, is the common practice of writing any time-related code with an explicit dependency on an external <code>Time</code> or <code>Clock</code> object, making something as seemingly universal as <strong>time</strong> configurable. Adam Keys has <a href="http://therealadam.com/2013/01/03/design-for-test-vs-design-for-api/">an excellent blog post on this point</a>, in which I think he gets to the heart of my argument pretty concisely:</p>

<blockquote>
<p>Even <strong>adding one optional parameter to a method carries “mass”</strong>.</p>
</blockquote>

<p>The “mass” is, of course, the cognitive load I mentioned of having to think about things that are flexible and non-global. My gut tells me that this predilection is particularly egregious in the Java and .NET communities, but I’ve seen it in Ruby land and elsewhere as well. And what this does is force undue attention on all of this configuration, much of which, most of the time, we ought to be taking for granted so that our minds can concentrate on more interesting issues.</p>

<p>This is why I enjoy working with convention-based frameworks. They shed much of this extra “mass,” enabling developers to take things for granted that would otherwise weigh us down.</p>

<p>So yes, maybe at its core <a href="http://en.wikipedia.org/wiki/Convention_over_configuration">convention over configuration</a> is just a fancy name for hidden global variables. But they’re carefully chosen variables, which—after an admittedly necessary learning curve—establish a deeper level of shared knowledge, freeing us to be more implicit and less explicit. And just like in real life, that’s often a good thing.</p>
<div class="footnotes">
<hr>
<ol>
<li id="fn:1">
<p>And yes, I realize that to any non-programmer that sounds completely absurd. <a href="#fnref:1" rev="footnote">↩</a></p>
</li>
<li id="fn:2">
<p>Think: the opposite of <em>locality</em>. <a href="#fnref:2" rev="footnote">↩</a></p>
</li>
<li id="fn:3">
<p>Scott, if you’re reading this, you know how it is: I will always disagree with you about everything. <a href="#fnref:3" rev="footnote">↩</a></p>
</li>
<li id="fn:4">
<p>Or whatever the expression-coiners are saying these days. <a href="#fnref:4" rev="footnote">↩</a></p>
</li>
<li id="fn:5">
<p>I interpreted Scott’s tweet as essentially a playful expression of mild concern as opposed to an outright attack on convention-based frameworks. I wrote this post more in response to that embedded assumption about global variables being bad than to the tweet directly. <a href="#fnref:5" rev="footnote">↩</a></p>
</li>
<li id="fn:6">
<p>An interesting discrepancy I have noticed between Linux enthusiasts and, say, Mac users (curiously, I find Windows users to be theoretically somewhere in between, even though that seems totally wrong) is in these users’ desire to configure their systems. Linux is extremely flexible in that you can change almost any aspect of the operating system to suit your needs. However, with this flexibility comes greater demand on the user to fully understand the system. OS X, in contrast, is extremely inflexible and therefore demands very little from the user, other than to learn its basic idioms, which Apple believes users will like. (What fools! Oh wait.) <a href="#fnref:6" rev="footnote">↩</a></p>
</li>
<li id="fn:7">
<p>If the stages of <em>grief</em> are denial, anger, bargaining, depression, and acceptance, the stages of using a convention-based framework might be: wonder, perplexity, anger, disgust, and finally enlightenment. Or something like that. <a href="#fnref:7" rev="footnote">↩</a></p>
</li>
<li id="fn:8">
<p>Here’s a fun exercise if you want to get really depressed: write a script (maybe you already have one) to count the lines of code on your software project. Now figure out how many of those lines are <em>application logic</em>–i.e., what your software is actually supposed to <em>do</em>–and compare that with the number that are just configuring factories, binding dependency injections, wiring up controllers and event buses and logging infrastructure and all that other good stuff. Feel good? <a href="#fnref:8" rev="footnote">↩</a></p>
</li>
</ol>
</div>]]></description><pubDate>Tue, 23 Apr 2013 12:49:00 -0700</pubDate><guid>http://philosopherdeveloper.com/posts/in-defense-of-global-state.html</guid></item><item><title>People are not resources</title><link>http://philosopherdeveloper.com/posts/people-are-not-resources.html</link><description><![CDATA[<p>I never actually worked in an environment like this, but I’ve read enough articles on <a href="http://thedailywtf.com/">The Daily WTF</a> to have an image in my head of the old dusty, temperamental servers that companies used to have back in the 90s and early 2000s.</p>

<p><img src="/images/ye-olde-server.jpg" alt="Ye olde server"></p><p>Ye olde server</p>

<p>Those were dark days, from what I hear—when your business was victimized at the whim of an unpredictable piece of hardware. If the power went out, or the CPU overheated, or the hard drive failed, your site went down. It was as simple as that.</p>

<p>We live in a different era now, with PaaS and IaaS and all that cloudy good stuff. Your average tech-savvy business owner is going to know there’s no particularly good reason to run your own server anymore if you’re a small company. And if you’re one of the large companies providing these services like <a href="http://aws.amazon.com/">Amazon</a> or <a href="https://cloud.google.com/">Google</a>, you have been on top of the hardware problem for a long time, with data centers distributed around the country (or the world) connected in a controllable and reliable way. It’s not an issue anymore.</p>

<p>This is a dream come true for everyone at the top of the food chain. The last thing you want in a high-up role is to be embarrassed by a problem at the bottom, far below eye level. The infrastructures that exist now for tech companies abstract servers into basically a sea of computing potential, which can be drawn from, predictably, as needed. (And on those rare occasions when outages <em>do</em> occur, it’s still nothing to lose sleep over. It’s Amazon’s problem; they’ll deal with it and apologize profusely in the morning.)</p>

<h2 id="dreaming_of_sliders_1">Dreaming of sliders</h2>

<p>Essentially hardware is now a <strong>slider system</strong>, where increased scalability demands call for nudging a slider up, at which point additional hardware is automatically provisioned and dedicated to storing your data, hosting your applications, etc. This is evident on sites like <a href="https://www.heroku.com/pricing">Heroku</a> and <a href="https://appharbor.com/pricing">AppHarbor</a>, which literally give you sliders to adjust how much computing power you want.</p>

<p class="full-size"><img src="/images/heroku-levers.png" alt="Herokus sliders for web dynos and worker dynos"></p><p>Herokus sliders for web dynos and worker dynos</p>

<p class="full-size"><img src="/images/appharbor-levers.png" alt="AppHarbors sliders for web workers and background workers"></p><p>AppHarbors sliders for web workers and background workers</p>

<p>I think there’s a similar dream a-brewin’ in the industry when it comes to people. I also think it’s wrong. But let me explain.</p>

<p>A couple of weeks ago, I read in the news that Apple <a href="http://www.techspot.com/news/52134-rumor-ios-7-behind-schedule-os-x-109-engineers-moved-to-help.html">was assigning some OS X engineers to work on iOS</a> to help get the next version of the mobile operating system back on schedule (apparently it was falling behind). It reminded me of a famous essay by Fred Brooks called <a href="http://www.amazon.com/The-Mythical-Man-Month-Engineering-Anniversary/dp/0201835959">The Mythical Man Month</a>, which is essentially a direct rebuttal of the notion that adding people to a software project speeds it up. Written in 1975 from experience at <a href="http://en.wikipedia.org/wiki/OS/360">IBM</a>, the essay provides a compelling argument that adding bodies to a delayed software project <em>actually delays it further</em>. This is now known as <a href="http://en.wikipedia.org/wiki/Brooks%27s_law">Brooks’s Law</a>:</p>

<blockquote>
<p>Adding manpower to a late software project makes it later.</p>
</blockquote>

<p>It has amazed me, ever since reading Brooks’s essay, how almost universally it seems companies ignore this principle<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>. They want <em>so badly</em> to be able to speed up software projects by adding engineers—to have greater control over their outcomes—that they’d rather believe Brooks’s Law is wrong, or pretend to have never heard of it, than take it seriously.</p>

<p><img src="/images/lalala.jpg" alt="I cant hear you!"></p><p>I cant hear you!</p>

<p>Because that’s the dream: <strong>companies want a slider system when it comes to people</strong>. Software project running behind schedule but you’ve got cash to spend? No problem! Just push the <em>manpower</em> slider up another 50% or so, and the project will zip right along up to your desired velocity.</p>

<p>A lot of what larger companies do is meant to facilitate this dream. They choose an approved set of tools and technologies. They prioritize extensive documentation on all of their projects and processes. They establish a clear and consistent onboarding process. The goal of all this being to establish a baseline that applies to every new employee, so that anyone who understands this baseline can be easily allocated to any project within the company with minimal ramp-up costs. (I’m reminded of tools like <a href="http://www.opscode.com/chef/">Chef</a> and <a href="https://puppetlabs.com/">Puppet</a> that serve a similar function for servers: establishing a baseline configuration so that machines can be seamlessly allocated to increase capacity.)</p>

<p>Remember that “sea of computing potential” I mentioned with hardware? This is what many companies want with people, too. It’s why the terms “human resources” or “human capital” exist: the more human resources I stockpile, the more manpower I have to throw at any project that I want done quickly.</p>

<h2 id="the_problem_with_viewing_people_as_resources_2">The problem with viewing people as resources</h2>

<p>I recognize that to a certain extent, the strategies I just described make sense for large companies with hundreds or thousands of employees. If you <em>know</em> developers are going to come and go—and <a href="https://twitter.com/holman/status/303576839132164097">unless you’re GitHub</a>, you’re kidding yourself to believe otherwise—you want to minimize the cost you pay each time that happens. It’s also good to give people as much mobility between projects as possible, not just for the company’s good but for theirs as well: no one wants to feel <em>stuck</em> on a project.</p>

<p>But I still think there’s a pretty big problem with this people-as-resources fantasy. Whenever I hear startup founders lament being low on “engineering resources,” I can’t help but feel their perspective is tragically distorted.</p>

<p>Startups traditionally seek out the best and brightest developers they can snag, and they’re often prepared to offer them substantial compensation (money, if they have funding, or equity) to do so. Most of the time, I believe this is wasteful. Why? Because of this people-as-resources notion, which is about abstracting engineers into a sea of engineering resources—so that when the business needs to scale, it can push up on the recruiting slider, get those engineers in the door, and really start cranking out product features (or whatever).</p>

<p><img src="/images/conch-shell.jpg" alt="Summon the developers!"></p><p>Summon the developers!</p>

<p>To be honest: I actually do buy into <a href="http://www.slideshare.net/slideshow/embed_code/8469957">the whole 10x thing</a>: that the best are 10x better than average<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>. Which implies it’s worth paying a lot for the best people. So why is it a waste of money, again? Because for this abstraction to work—this idea that people are resources—individuals need to be <em>equalized</em> somehow, so that adding and subtracting them from the pool has predictable results. And equalization by definition requires <strong>dragging the top down while pulling the bottom up</strong>. When you hire based on 10x but then proceed to chase after the “resources” fantasy, you’re basically throwing money away, buying at the top and then pulling down towards the middle.</p>

<p>An interesting comparison I’d make here is to how Google famously uses commodity hardware in their data centers. At one point in history this seemed counterintuitive to a lot of people; but I think by now enough other companies have scaled to the extent that many have learned the same lesson: in terms of cost per CPU power, you get a lot more bang for your buck—more <em>value</em>–by buying cheap servers and scaling horizontally. If you want to do the same with people, you need to <a href="http://www.imdb.com/title/tt1210166/">Moneyball</a> it: seek the most under-valued individuals you can find, knowing they aren’t “star” players but confident that your equalization strategy will whip them into shape, netting your company another <a href="https://devcenter.heroku.com/articles/dynos#the-dyno-manifold">dyno to add to the manifold</a>.</p>

<h2 id="which_is_it_going_to_be_3">Which is it going to be?</h2>

<p>I suspect there are many who would argue with me on this point, insisting that hiring the best people still delivers good value because, proportionally, if someone is 10x average but I’m only paying 2x average, I’m actually coming out ahead. Of course, this does make sense mathematically; but I think it’s kind of missing the whole point of what I’m saying.</p>

<p>If your goal is to get a good <em>value</em> out of someone, that essentially means you’re looking to under-compensate them somehow. I don’t mean to suggest you should offer 10x the average salary for people who are really worth it. I just mean that this mentality by its very nature treats team-building as a zero-sum game, where the company benefits by paying its employees as little as possible—and there is no downside, because people are resources. This sets up the relationship from the very beginning in a bad direction. Either this person will become bitter about the arrangement and leave, or they’ll simply become complacent and start performing way below their potential—at which point, there goes the value you were so excited about.</p>

<p><img src="/images/dilbert-life-suck.gif" alt="What happens to people treated like resources"></p><p>What happens to people treated like resources</p>

<p>So I think you need to pick one: either view people as <em>teammates</em> that you’re going to bring on for their creativity and their ideas and give as much freedom as you would want in their shoes; or view them as resources and give up on going for the “best” because you’ll just end up overpaying.</p>
<div class="footnotes">
<hr>
<ol>
<li id="fn:1">
<p>For this reason Brooks has lovingly referred to <em>The Mythical Man Month</em> as “the Bible of software engineering”: “everybody quotes it, some people read it, and a few people go by it.” <a href="#fnref:1" rev="footnote">↩</a></p>
</li>
<li id="fn:2">
<p>Or, I don’t know, maybe not 10x. There’s just a big difference; that’s all I’m saying. <a href="#fnref:2" rev="footnote">↩</a></p>
</li>
</ol>
</div>]]></description><pubDate>Wed, 17 Apr 2013 18:36:00 -0700</pubDate><guid>http://philosopherdeveloper.com/posts/people-are-not-resources.html</guid></item><item><title>Risk aversion and software development</title><link>http://philosopherdeveloper.com/posts/risk-aversion-and-software-development.html</link><description><![CDATA[<p>A few years ago my parents gave me and my wife this knife as a Christmas present:</p>

<p><img src="/images/shun-utility-knife.jpg" alt="The Shun Classic Utility Knife"></p><p>The Shun Classic Utility Knife</p>

<p>We weren’t quite sure what to make of it at first, but it wasn’t long before we both loved it. It is a <em>very</em> sharp knife, which makes it a breeze to cut through just about anything. Unfortunately, that <em>anything</em> includes human flesh. I know this because a few months after receiving the knife I was cutting an avocado and the knife slipped in my hand. It was quite a bad cut.</p>

<p>Obviously—I still have all ten fingers—my wound healed eventually. But I do have a pretty clear memory of the incident, which makes me quite fearful of repeating it. Here are two ways I could protect myself from future self-inflicted injury:</p>

<ol>
<li>Decide <strong>the knife is too sharp</strong>. I could replace the Shun knife with a duller one, so that if my hand ever slips while cutting again the injury won’t be so bad.</li>

<li>Decide <strong>I wasn’t careful enough</strong>. In the future I could cut more slowly and be very cautious whenever I’m using the knife.</li>
</ol><p>I believe these are the same two options many developers choose between when building software.</p>

<p>In the first camp, you have the mentality that our tools must be safe and protect us from harm. This is a classic reason to prefer statically typed languages like Java or C#: the compiler can tell me when I’ve done something wrong! A significant number of potential bugs are eliminated before human consideration even enters the picture. This makes it nearly impossible to actually ship code with boneheaded mistakes like typos, syntax errors, etc.</p>

<p>In the second camp, there’s the philosophy that we must practice restraint in our development efforts. Teams with this attitude may use dynamic languages like Ruby or JavaScript, for example, but still might enforce strict guidelines as to how code should be written, reviewed, and deployed. They might require code reviews before every commit. Maybe they’ll even write their own static analysis tools to gain back some of the safety (and performance) of statically typed languages. And they will almost certainly have a process in place that establishes <em>some</em> safeguards before code is pushed to production.</p>

<p>Besides these two approaches, I propose that there is a third option.</p>

<p><img src="/images/better-way.gif" alt="Or at least, a different way"></p><p>Or at least, a different way</p>

<p><strong>I could just continue to use the knife as before.</strong> Sure, I cut myself, and it hurt; but in the end, I healed. It was a pretty minor wound<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>, in the grand scheme of things. And in software, except in some rare cases, we’re not talking life or death. Even at large companies with a great deal on the line I’d argue this applies in most everyday cases; but it’s <em>especially</em> true at smaller companies, where remaining nimble—and responding quickly to change—is so much more important than avoiding risk.</p>

<p>Put another way: I could spend the rest of my life cutting very slowly to reduce the risk of injuring myself; or I could let myself move quickly and live with the risk of sometimes drawing a little blood. Over time I believe the latter approach leads to greater total progress<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>.</p>
<iframe src="http://charter.herokuapp.com/embed/136BV6U4" style="height: 450px; width: 600px;"></iframe>
<p>I recognize that my knife analogy starts to break down right about now, because the total amount of time we’re talking about over the course of my life is pretty insignificant. If I were a professional chef, I think the literal lesson might still apply. As it happens, I’m a professional software developer; and the <em>figurative</em> lesson applies as much to those in our field as to anybody, if not more so.</p>

<p>I’m not saying don’t be careful. Of course you could easily take this argument too far. But I suspect that many companies have already gone too far down one of the first two paths I described; and we should always remember the third option exists.</p>
<div class="footnotes">
<hr>
<ol>
<li id="fn:1">
<p>Don’t get me wrong; it was actually a very bad cut that took nearly a month to heal. But the fact remains that it <em>did</em> heal. It isn’t like I lost a limb. So I maintain that, relatively speaking, it was quite minor. <a href="#fnref:1" rev="footnote">↩</a></p>
</li>
<li id="fn:2">
<p>Hey by the way, that chart was made using a tool called <a class="new-window" href="http://charter.herokuapp.com/">Charter</a>, <em>another</em> one of my open source projects! (And Charter itself uses <a class="new-window" href="http://dtao.github.io/HighTables/">HighTables</a>–that’s what they call dogfooding, my friends.) <a href="#fnref:2" rev="footnote">↩</a></p>
</li>
</ol>
</div>]]></description><pubDate>Thu, 11 Apr 2013 19:17:00 -0700</pubDate><guid>http://philosopherdeveloper.com/posts/risk-aversion-and-software-development.html</guid></item><item><title>Charts made dead simple with HighTables</title><link>http://philosopherdeveloper.com/posts/charts-made-dead-simple-with-hightables.html</link><description><![CDATA[<p>In a footnote to <a href="/posts/making-yaml-safe-again.html">my post a while ago on SafeYAML</a><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>, I established a goal of writing more about my many open source projects, which I have a bad habit of not telling anyone about—sometimes even long after they’re finished!</p>

<p>So today I want to write about a pretty good one that’s relatively polished and full-featured. It’s called <a href="http://dtao.github.io/HighTables/">HighTables</a>, and it’s a JavaScript library that makes adding charts to existing sites with HTML tables <em>extremely</em> easy.</p>

<p>Here, I’ll give you an example (<strong>note</strong>: this is probably not going to display properly for those of you on RSS readers; <a href="http://philosopherdeveloper.com/posts/charts-made-dead-simple-with-hightables.html">visit the website</a> to see what I’m trying to show you!):</p>

<div class="highlight"><pre><span class="nt">&lt;table</span> <span class="na">class=</span><span class="s">"render-to-bar-chart"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;tr&gt;</span>
    <span class="nt">&lt;th&gt;</span>Method of rendering a chart<span class="nt">&lt;/th&gt;</span>
    <span class="nt">&lt;th&gt;</span>How easy it is (scale from 1 to 10)<span class="nt">&lt;/th&gt;</span>
  <span class="nt">&lt;/tr&gt;</span>
  <span class="nt">&lt;tr&gt;</span>
    <span class="nt">&lt;td&gt;</span>Using Highcharts directly<span class="nt">&lt;/td&gt;</span>
    <span class="nt">&lt;td&gt;</span>3<span class="nt">&lt;/td&gt;</span>
  <span class="nt">&lt;/tr&gt;</span>
  <span class="nt">&lt;tr&gt;</span>
    <span class="nt">&lt;td&gt;</span>Using HighTables<span class="nt">&lt;/td&gt;</span>
    <span class="nt">&lt;td&gt;</span>10<span class="nt">&lt;/td&gt;</span>
  <span class="nt">&lt;/tr&gt;</span>
<span class="nt">&lt;/table&gt;</span>
</pre></div>

<p>And the result:</p>
<table class="render-to-bar-chart">
<tr>
<th>Method of rendering a chart</th>
    <th>How easy it is (scale from 1 to 10)</th>
  </tr>
<tr>
<td>Using Highcharts directly</td>
    <td>3</td>
  </tr>
<tr>
<td>Using HighTables</td>
    <td>10</td>
  </tr>
</table><p>Pretty cool, right?</p>

<p>For what it’s worth, HighTables itself isn’t all that complicated. It leverages the power of two existing libraries, <a href="http://www.highcharts.com/">Highcharts</a> and <a href="http://jquery.com/">jQuery</a>. If you don’t know about Highcharts, it’s a great library that lets you render all kinds of charts (line, area, bar, pie, etc.) in JavaScript. And if you don’t know about jQuery, and you’re a JavaScript developer, you should probably blow the dust off your keyboard and <a href="http://www.doxdesk.com/img/updates/20091116-so-large.gif">ask any JS-related question on the internet</a> to learn more about it.</p>

<p>My problem with Highcharts in the past was that it has <a href="http://api.highcharts.com/highcharts">a <em>behemoth</em> API</a>. Rendering a chart was never a simple matter of calling <code>pieChart()</code>; instead, any chart-creation logic requires a whole ton of options that an average person is very unlikely to remember from one use to the next. And so I always found myself returning to the Highcharts website, perusing documentation, and following examples to ever get a chart to display on sites I’ve worked on.</p>
<figure class="hidden-in-abbreviated-version"><div class="pie-chart" data-title="Value of activity" data-source="#activity-value-vs-time-table" data-value-columns="2" data-options="getChartOptions"></div>
  <div class="pie-chart" data-title="Time invested in activity" data-source="#activity-value-vs-time-table" data-value-columns="3" data-options="getChartOptions"></div>
  <figcaption>Notice any discrepancy?</figcaption></figure><table id="activity-value-vs-time-table" class="hidden">
<thead><tr>
<th>Activity</th>
<th>Relative Value of activity</th>
<th>Hours spent on activity</th>
</tr></thead>
<tbody>
<tr>
<td style="text-align: left;">Implementing reporting backend</td>
<td style="text-align: right;">10</td>
<td style="text-align: right;">3</td>
</tr>
<tr>
<td style="text-align: left;">Fiddling with chart rendering</td>
<td style="text-align: right;">1</td>
<td style="text-align: right;">5</td>
</tr>
</tbody>
</table><p>Of course, like any good developer, I eventually would get around to writing reusable methods with easier-to-remember interfaces and use <em>those</em> to render my charts. But at some point I noticed a pattern: mostly I was putting charts <strong>where tables already were</strong>. The point of the chart was to display the data in a visual form, to make it a bit easier to parse for a human. The work of translating the data in the table to JavaScript code to render the chart was tedious, but easily repeatable.</p>

<p>And from there came the realization that I could (and probably should) just automate every bit of the process, and write a <em>library</em> to <em>always</em> render a chart from a table—provided that table had some class (like <code>render-to-line-chart</code>) associated with it. So that’s exactly how HighTables works: you add one class to your table, include the library in your page, and charts display automatically. (The charts above are rendered from <a href="javascript:revealTable();">a hidden table</a>, by the way, in case you were confused!)</p>

<p>So, by all means, <a href="https://github.com/dtao/HighTables">try out HighTables</a> and let me know what you think! I’ve already used it a good deal myself, and I can honestly say it’s been really useful to me. But the more use it gets, the more useful it should become as bugs are fixed, features are introduced, yada yada. At least that’s the hope.</p>
<div class="footnotes">
<hr>
<ol><li id="fn:1">
<p>Which <a href="http://rubygems.org/gems/safe_yaml">has come a long way</a>! <a href="#fnref:1" rev="footnote">↩</a></p>
</li></ol>
</div>]]></description><pubDate>Wed, 10 Apr 2013 08:34:00 -0700</pubDate><guid>http://philosopherdeveloper.com/posts/charts-made-dead-simple-with-hightables.html</guid></item><item><title>Am I an engineer?</title><link>http://philosopherdeveloper.com/posts/am-i-an-engineer.html</link><description><![CDATA[<p>Most people outside of the software development profession (and even many on the inside) may not realize that there is some disagreement within the community as to whether or not software development is a form of <em>engineering</em>.</p>

<p>Let’s say you placed software developers along a spectrum, where at one end “engineering” might as well be a foreign word, and at the other end writing software is <em>obviously</em> a form of engineering, in much the same way that painting or sculpture is obviously a form of art.</p>

<p class="plain"><img src="/images/engineering-spectrum.png" alt="Is software development a form of engineering?"></p><p>Is software development a form of engineering?</p>

<p>Personally, I have worked at various points along this spectrum. My first developer job was at a trading company in Philadelphia, which would have fallen pretty close to the extreme left end. At <a href="http://www.thoughtworks.com">ThoughtWorks</a> I would say the culture was somewhere in the middle, with plenty of developers leaning in both directions (I definitely worked with self-professed “engineers” at ThoughtWorks, as well as individuals who vehemently rejected the label).</p>

<p>More recently I’ve worked in environments that fall much closer to the right side of the spectrum. The culture at <a href="http://www.cardpool.com">Cardpool</a>–founded by two former Microsoft employees and with its first two hires from Google—was, not surprisingly, firmly in the software-as-engineering camp. I would expect no different from most large software companies (or developers with large company roots). And a couple of weeks ago I started at Google myself, which I’m guessing will be about as far to the right as I’ll ever get in my career.</p>

<p>(By the way, it’s probably not a coincidence that I chose to assign the left and right sides of the spectrum to the viewpoints that I did; read <a href="https://plus.google.com/110981030061712822816/posts/KaSKeg4vQtz">Steve Yegge’s argument</a> that software developers fall into “liberal” and “conservative” groups to get an interesting view on a related subject. And while you’re at it, also read Richard Gabriel’s <a href="http://www.dreamsongs.com/RiseOfWorseIsBetter.html">The Rise of <em>Worse is Better</em></a> for a much older but very similar perspective on two approaches to software, which he deems the <em>MIT approach</em> versus the <em>New Jersey approach</em>.)</p>

<p>A term that seems to have grown in popularity since I’ve been working is <em>software craftsman</em>. I don’t know that this term is always intended to be in direct opposition to the idea of “software engineering”; but I think it is nonetheless a handy reference point to provide contrast to the perspective that software is definitely engineering.</p>

<p>Which brings me to a disclaimer I probably should have made earlier: I myself lean towards the left on this spectrum, so I am biased. That said, I don’t consider either side to be the “correct” way of viewing software; and in fact, I believe the very attitude that holds one side to be superior to another is probably the most “incorrect” of all possible views on the topic. My primary reason for bringing this up is simply to point out that these different perspectives exist, and to do my best to highlight some important ways in which they are similar, despite their obvious differences.</p>

<p>But before I continue: <strong>what am I even talking about?</strong> I’m sure at least <em>someone</em> reading this has no idea what the terms “engineer” or “craftsman” are supposed to suggest. So let me provide a (relatively) quick, totally oversimplified characterization of each of these ideas.</p>

<h2 id="what_is_an_engineer_1">What is an engineer?</h2>

<p><img src="/images/engineer-at-work.jpg" alt="An engineer at work"></p><p>An engineer at work</p>

<p>In <strong>broad, overly general terms</strong>, here’s how I’d describe a software engineer.</p>

<p>Her <strong>code is the product</strong>. She takes pride in its quality and thinks through her designs carefully.</p>

<p>Of course, she wants her code to lead to useful software, which is why it is important that significant thought goes into writing requirements as well. Sometimes an engineer will take ownership of a project’s requirements, but sometimes that will be someone else’s job. If her code is written well and meets requirements, but those requirements turned out to be wrong or poorly defined, an engineer may still feel proud of her work. Her code could still be elegant, even if the product as a whole didn’t turn out to be a success for other reasons.</p>

<p>To an engineer, <strong>the practice of writing software is a discipline</strong>. There is a right way to do it; and although it’s naturally impossible to ever achieve perfection, knowledge and experience equip good engineers to get closer and closer over time, as they learn from experience and apply what they’ve learned to their future work. For this reason an engineer will prefer to formalize her knowledge over time in the form of policies and conventions that can be applied at the team level.</p>

<p>If I may be abstract for a moment, I picture an engineer’s development—not of code, but of herself—as being like the growth of a redwood: up and up, better and better.</p>

<p><img src="/images/redwood-tree.jpg" alt="An engineer grows like a redwood."></p><p>An engineer grows like a redwood.</p>

<p>More experience → more knowledge.</p>

<h2 id="what_is_a_craftsman_2">What is a craftsman?</h2>

<p><img src="/images/craftsman-at-work.jpg" alt="A craftsman at work"></p><p>A craftsman at work</p>

<p>Just a reminder: I am biased here. But this is roughly what being a “craftsman” means, in my mind.</p>

<p>His <strong>code is a tool</strong>. A tool degrades and becomes blunt over time; this is unavoidable. But naturally, if a tool is important then a craftsman will sharpen it periodically. Tools that are seldom used and have worn out or rusted can simply be replaced or discarded.</p>

<p>A craftsman cares more that his code leads to useful software than that it is elegant or well designed. In fact, if he spent time making his code elegant but the requirements were poorly designed and the resulting software is not useful, a craftsman will be deeply upset because his time was wasted. For this reason he will almost always take at least partial ownership in ensuring that the requirements for a project make sense.</p>

<p>To a craftsman, <strong>writing software is a craft</strong>, based on creativity and technique. There is not a “right” way; there are many ways. Experience alone does not necessarily bring one closer to an ideal (because there is no single ideal). Instead, the more a craftsman learns, the more diverse his set of tools becomes; and his craft is more colorful as a result. A craftsman is less likely than an engineer to adopt formal rules or advocate team-wide policies, since to him code is a relatively personal thing.</p>

<p>I imagine a craftsman’s growth as more like that of baobab tree: out and out, broader and broader.</p>

<p><img src="/images/baobab-tree.jpg" alt="A craftsman grows like a baobab."></p><p>A craftsman grows like a baobab.</p>

<p>More experience → more perspective.</p>

<h2 id="where_the_two_shall_meet_3">Where the two shall meet</h2>

<p>As I said, I don’t think either of these approaches is wrong. It’s worth pointing out that both of these mentalities share the same underlying motivation: we all want to build high-quality software. It’s also worth mentioning that even though I’ve painted a contrasting picture of these two types, it isn’t like the things I said about engineers are completely untrue of craftsmen or vice versa. Most engineers certainly care that the software they build ends up doing something useful for someone, and craftsmen naturally enjoy (and even prefer) writing elegant code if they can. The real difference between the two is a matter of <em>relative weight</em> rather than stark acceptance or rejection of principles.</p>

<p>Unfortunately, even though we all may be cut from the same cloth deep down, I tend to feel that it is difficult, and probably inadvisable, to attempt to incorporate both cultures into a single team. Either one or the other view of software development is likely to prevail in a group setting by sheer majority, and those on the other side of the spectrum will not do their best work. Craftsmen in an engineering culture will inevitably feel stifled, while engineers in a craftsmanship culture will become frustrated at what they may perceive as a lack of discipline or consistency.</p>

<p>So if you are in the position of building a software team, it’s worth reflecting for a moment on what the team’s culture currently is (if you’re adding to an existing team) or what you want it to be (if you’re building one from scratch). I’m not saying that if you’re assembling a craftsmanship-style team you should reject all résumés with the words “software engineer” on them; that would be absurd. But as part of the interview process I do think it would be worth your while to try and ascertain where any potential teammates lie on the software-as-engineering spectrum.</p>

<p>Naturally, people are adaptable. Part of the reason I decided to join Google was that I want to learn more about the software engineering culture, and to see what it’s like at a company that has been so successful from it. Just recognize that <em>cultural fit</em> is about more than whether you would be glad to get a beer with someone. I would argue that the worst case scenario<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> for your team would be to bring someone very talented on board who ultimately cannot adjust to your culture. In that case you probably won’t benefit from his or her potential nearly as much as you should, simply because we’re all more productive when working in an environment we can identify with.</p>

<h2 id="does_size_matter_4">Does size matter?</h2>

<p>Among the myriad questions and objections you may find yourself thinking of in response to my position here, I suspect one of them might be: <em>what about large projects?</em> It’s an interesting question: surely you wouldn’t put a team of <em>craftsmen</em> on a large-scale project, would you? Even if we accept that the two approaches to software that I’ve described are both valid in some sense, it would seem that the more structured and organized style of engineers would lend itself better to building large software systems and working together in large groups.</p>

<p><img src="/images/bridge-under-construction.jpg" alt="Would you trust a bunch of craftsmen with something like this?"></p><p>Would you trust a bunch of craftsmen with something like this?</p>

<p>I tend to agree with the spirit of this question, but I think there are at least two ways in which it is partially misguided.</p>

<ol>
<li>As I said, people can adapt. This includes craftsman-style developers. Assigned to a large project with a sizable team, I’m confident that any good team—on either side of the spectrum—would adopt a fairly disciplined approach to building the software, with much more structure than perhaps they would on a smaller project.</li>

<li>However, the question implies<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> a certain inevitability to the need for a team to work on a large-scale project. I would challenge this assumption, and return to my earlier point about requirements. I suspect that in many cases, software projects that end up becoming large have little justification for getting that way. Sometimes the size and complexity of a piece of software inflates with the size of the team, forming a harmful feedback loop that leads to bloat. But that’s a topic for another post.</li>
</ol><p>In any case, it is probably true that sometimes large software projects are justifiable<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>; and these require a great deal of organization and collaboration to run smoothly. And so an engineering culture is likely to emerge on these projects, regardless of the sort of software developers working on them. That said, it may sometimes also be possible to break a large project down into smaller projects, in which case semi-autonomous teams might still flourish with a craftsmanship culture.</p>

<h2 id="closing_thoughts_5">Closing thoughts</h2>

<p>I’ve said that it can be difficult for these two kinds of software developers to work together. Regardless, I still believe we have a lot to learn from one another by crossing from one side of the spectrum to the other on a regular basis, at least socially if not professionally. So think about whether you’re more like a “craftsman” or more like an “engineer” as I’ve described them<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>, and seek out people who you think are different from you.</p>

<p>The fact that Richard Gabriel wrote about the MIT approach and the New Jersey approach <em>decades</em> ago—and it still feels relevant today—says something to me. Gabriel may have concluded that “Worse is Better”; but it’s clear to me that, just as there will always be different personalities, both philosophies of software development are here to stay. So let’s do our best to understand each other—or at least not kill each other.</p>
<div class="footnotes">
<hr>
<ol>
<li id="fn:1">
<p>OK, maybe not <em>worst</em> case scenario. But it would still be unfortunate. <a href="#fnref:1" rev="footnote">↩</a></p>
</li>
<li id="fn:2">
<p>At least in tone, the way I hear it in my head. <a href="#fnref:2" rev="footnote">↩</a></p>
</li>
<li id="fn:3">
<p>It seems pretty clear to me that Google is a perfect example of this. <a href="#fnref:3" rev="footnote">↩</a></p>
</li>
<li id="fn:4">
<p>I almost worded this, “whether you <em>are</em> a craftsman or an engineer”; but let’s not get caught up in the idea that these terms actually define individuals. It is a convenient mental grouping, for me; but we are all obviously different and how you define yourself may not jive with the division I’ve drawn here at all—in which case, let me know! Leave a comment, or write an e-mail, or just come talk to me some time if we work together. <a href="#fnref:4" rev="footnote">↩</a></p>
</li>
</ol>
</div>]]></description><pubDate>Wed, 03 Apr 2013 13:18:00 -0700</pubDate><guid>http://philosopherdeveloper.com/posts/am-i-an-engineer.html</guid></item></channel></rss>