<!DOCTYPE html>
<html>
  <head>
    <title>The Philosopher Developer</title>
    <meta charset='utf-8' />
    <meta content='initial-scale=1.0, width=device-width, user-scalable=no' name='viewport' />
    <link href='/stylesheets/application.css' rel='stylesheet' />
    <link href='/stylesheets/pygments.css' rel='stylesheet' />
    <script src='http://w.sharethis.com/button/buttons.js' type='text/javascript'></script>
    <script src='/javascripts/ga.js' type='text/javascript'></script>
    <script src='/javascripts/shareThis.js' type='text/javascript'></script>
    <script src='/javascripts/jquery-1.9.1.min.js' type='text/javascript'></script>
    <script src='/javascripts/main.js' type='text/javascript'></script>
    
    <script type='text/javascript' src='/javascripts/posts.js'></script>
  </head>
  <body>
    <header id='header'>
      <h1><a href="/">The Philosopher Developer</a></h1>
      <h2>half-sound logic, half-decent code</h2>
    </header>
    <article class='abbreviated'>
  <header>
    <h1>
      <span class='title'>
        <a href='/posts/being-agile-with-continuous-integration.html'>Being agile with continuous integration</a>
      </span>
      <span class='date'>January 27, 2012</span>
    </h1>
  </header>
  <section class='content'>
    <p>Something’s been stirring around in my head lately, and it’s going to seem somewhat heretical to those firmly planted in a particular school of thought. Essentially I’ve been questioning the way continuous integration is done on some of the software projects I’ve seen, at ThoughtWorks and elsewhere.</p>
    
    <p>More broadly, I guess my skepticism isn’t specifically about continuous integration, but rather about test-driven development with TDD and, more importantly, BDD (i.e., with a language like Gherkin/Cucumber for defining feature requirements and a UI automation tool such as Selenium for driving acceptance tests).</p>
    
    <p>To be clear, I view TDD and BDD as extremely useful techniques; and CI is a powerful tool to maximize their effectiveness. I would even accept that we are better off using a test-driven approach for 100% of development than we would be if we used no TDD. But that isn’t the same as saying 100% TDD is optimal or that we should get started with BDD immediately on every project. Like most everything else in life, I believe it is ultimately a matter of achieving the right balance, which requires good judgment.</p>
    
    <p>As a bit of background, I have had conversations with colleagues who have agreed with me that sometimes testing is not necessary or appropriate. The attitude I have picked up as a general rule of thumb is that for spiking out software prototypes—throwaway versions that we acknowledge in advance will probably differ dramatically from any actual release—we can often move faster by coding features without testing them. TDD might still be useful in this context, however, as one of its benefits is that it assists the developer in thinking through the implementation of a tricky piece of logic. But its usefulness here is actually in <em>increasing</em> development speed (which is important for a prototype), not in <span class="post-link">... (<a href="/posts/being-agile-with-continuous-integration.html">read the full post</a>)</span></p>
  </section>
</article>
<article class='abbreviated'>
  <header>
    <h1>
      <span class='title'>
        <a href='/posts/ghost-clicks-in-jquery-mobile.html'>Ghost clicks in jQuery Mobile</a>
      </span>
      <span class='date'>November 01, 2011</span>
    </h1>
  </header>
  <section class='content'>
    <p>I know it’s been a long time since I’ve written (<em>especially</em> for someone who’s repeatedly claimed he will write daily posts). I’ve got some more substantial ideas to discuss in the near future (honest!)<strike>, but this particular post is going to be a short one</strike>. [Correction: this post ended up being kinda long.]</p>

<p>On my current project we’re in the process of wrapping up a mobile website we built using <a href="http://jquerymobile.com/">jQuery Mobile</a>. One issue we encountered during development was that on certain pages, a strange “ghost click” behavior was observed: the user would click a button, the page would change, and then a button on the destination page (positioned at the same location as the original button) would seem to be automatically clicked as if the user had clicked twice—or as if a <em>ghost</em> had clicked it.</p>

<p>It turns out that this is a known issue for mobile web browsers, which <a href="http://code.google.com/mobile/articles/fast_buttons.html">Google wrote about back in January</a>. In the article, Ryan Fioravanti explains that most mobile browsers introduce a delay of ~300 ms before every <code>click</code> event, for the reason that they want to account for the possibility that the user might be double-clicking to zoom in on the page. So what can happen on a mobile web project this:</p>

<ul>
<li>Someone notices that the UI seems sluggish. In particular, clicking on buttons feels very slow.</li>

<li>A developer looks into the problem and finds that the issue can be mitigated by handling an event other than <code>click</code>, such as <code>touchstart</code> (jQuery Mobile has a <code>vclick</code> event).</li>

<li>Now that the clickable element in question handles a non-<code>click</code> event, when it is clicked, <strong>there is still a <code>click</code> event waiting to be triggered within the next ~300 ms</strong>; and so if a page <span class="post-link">... (<a href="/posts/ghost-clicks-in-jquery-mobile.html">read the full post</a>)</span>
</li>
</ul>
  </section>
</article>
<article class='abbreviated'>
  <header>
    <h1>
      <span class='title'>
        <a href='/posts/sometimes-the-best-strategy-is-to-retreat.html'>Sometimes the best strategy is to retreat</a>
      </span>
      <span class='date'>February 28, 2011</span>
    </h1>
  </header>
  <section class='content'>
    <p>I have a few remarks to make about <a href="http://dtao.github.com/ConcurrentList/">my <code>ConcurrentList&lt;T&gt;</code> class</a>, which I have written about a <a href="/posts/how-to-build-a-thread-safe-lock-free-resizable-array.html">couple</a> of <a href="/posts/boy-can-dream.html">times</a> already.</p>

<p><em>What, are you “retreating” from your concurrent list idea?</em> In a way, yes. Let me explain. From the beginning, my concept of the usefulness of a lock-free <code>IList&lt;T&gt;</code> implementation was that it would scale better than using a <code>List&lt;T&gt;</code> plus <code>lock</code> statements by eliminating contention when many threads are accessing the list concurrently.</p>

<p>Is this actually true? Accessing the list <code>how</code>?</p>

<p>Since a concurrent implementation of <code>Insert</code>, <code>RemoveAt</code> etc. is not supported in <code>ConcurrentList&lt;T&gt;</code>, there are really only a few operations that need to be considered:</p>

<ul>
<li>Getting/setting an item at a specified index</li>

<li>Adding to the list</li>

<li>Iterating over the list</li>
</ul><p>Critically, I think the assumption is that one would need a lock-free data structure to optimize the scenario where multiple threads may be <em>reading</em> from the list (via accessing items at random indexes) while one or more other threads are <em>adding</em> to it. <strong>I actually don’t think you need a lock-free data structure for this at all.</strong></p>

<p>Here’s the thing: if you’ve got a <code>List&lt;T&gt;</code>, and you synchronize all calls to <code>Add</code> with, e.g., a <code>lock</code> statement, <strong>you don’t need to also synchronize reads</strong>. They will <em>always</em> be thread-safe. Accessing an element at an index of a <code>List&lt;T&gt;</code> that is <em>only</em> growing with calls to <code>Add</code> <em>will</em> work from multiple threads. If you are skeptical, consider what actually happens when <code>Add</code> is called (<strong>warning: reliance upon specific implementation details ahead!</strong>):</p>

<ol>
<li>
<p>The <code>List&lt;T&gt;</code> gets the next available index in its internal array.</p>
</li>

<li>
<p>If the index is beyond the end of the array:</p>

<ol>
<li>A new array is allocated.</li>

<li>The elements of the current array are copied over.</li>

<li>A reference to this new <span class="post-link">... (<a href="/posts/sometimes-the-best-strategy-is-to-retreat.html">read the full post</a>)</span>
</li>
</ol>
</li>
</ol>
  </section>
</article>
<article class='abbreviated'>
  <header>
    <h1>
      <span class='title'>
        <a href='/posts/boy-can-dream.html'>A boy can dream...</a>
      </span>
      <span class='date'>February 24, 2011</span>
    </h1>
  </header>
  <section class='content'>
    <p>Well, I’ve finished an initial implementation of a <code>ConcurrentList&lt;T&gt;</code> data structure. It implements the <code>IList&lt;T&gt;</code> interface (partially—no <code>Insert</code>, <code>RemoveAt</code>, etc.–it is an append-only structure) and is both <strong>thread-safe</strong> and <strong>lock-free</strong>.</p>

<p>(I also came up with a few different ways to resolve the <code>Count</code> issue mentioned in my previous post; what I’ve settled on for now is basically the most obvious and straightforward version.)</p>

<p>The source code for the class itself is available to view in my GitHub repository here:</p>

<p><a href="https://github.com/dtao/ConcurrentList"><strong>Check out the source code.</strong></a></p>

<p>Now for the somewhat disheartening part: thus far, based on my own performance benchmarks, I see little evidence that this actually outperforms a simple <code>List&lt;T&gt;</code> with synchronized calls to <code>Add</code> (using, e.g., a <code>lock</code> statement). So that’s a bit disappointing. But I figured I’d share the source code, in case some hackers out there might be able to figure out how to make it better.</p>

<p>Also, I feel like part of the issue I may be having is that it’s tough to really create a lot of thread contention on a puny little laptop with such a lightweight method (I’d wager <code>List&lt;T&gt;.Add</code> couldn’t be much more than 10 lines). So maybe if this could get tested on a 32-core server somewhere, the results would be more noteworthy. I don’t know!</p>

<p>Anyway, at least it passes the unit tests. That’s got to be worth something, right?</p>
  </section>
</article>
<article class='abbreviated'>
  <header>
    <h1>
      <span class='title'>
        <a href='/posts/how-to-build-a-thread-safe-lock-free-resizable-array.html'>How to build a thread-safe lock-free resizable "array"</a>
      </span>
      <span class='date'>February 23, 2011</span>
    </h1>
  </header>
  <section class='content'>
    <p><strong>Update: I’ve finally (nearly two years later) created a <a href="http://dtao.github.com/ConcurrentList/">dedicated GitHub repo</a> for this.</strong></p>
<hr><p>Inspired by <a href="http://stackoverflow.com/questions/5070495/lock-free-thread-safe-ilistt-for-net">this Stack Overflow question</a>, I started thinking about possible ways of implementing the <code>IList&lt;T&gt;</code> interface in a lock-free <em>concurrent</em> data structure, with the following notes:</p>

<ol>
<li>I highly doubt a lock-free <code>Insert</code> or <code>RemoveAt</code> implementation is possible. I could be wrong, of course; but I don’t think so. So I would implement those explicitly (and throw a <code>NotSupportedException</code>).</li>

<li>I would want guaranteed O(1) random access, at least. (Otherwise, the whole point of implementing <code>IList&lt;T&gt;</code> seems kind of questionable.)</li>
</ol><p>OK, so, <strong>how do we do it</strong>?</p>

<p>Before I even describe my idea (still a work in progress), I should disclose the fact that, to my simultaneous disappointment and delight, it appears I managed to come up with a concept on my own that is <em>remarkably</em> similar to what researchers at Texas A&amp;M University, including <a href="http://en.wikipedia.org/wiki/Bjarne_Stroustrup">Bjarne Stroustrup</a>, <a href="http://www.stroustrup.com/lock-free-vector.pdf">designed and published</a>.</p>

<p>Here’s the basic idea. Clearly utilizing a single array that is resized on certain Add operations would be problematic: allocating a new array and copying all elements to it in a lock-free way would be, at least I have to speculate, quite costly (imagine multiple concurrent threads all copying elements concurrently—seems very wasteful). So I considered using a <em>linked list</em> of arrays, where when an Add call requires additional storage, a new array could be allocated and appended to the linked list. But once you introduce a linked list, random access in O(1) becomes, well, less possible.</p>

<p>I was <em>thinking</em> you probably couldn’t do it with a simple array of arrays (e.g., a <code>List&lt;T[]&gt;</code>) simply because then you’d eventually run into the problem of having to resize the “outer” array eventually. But then it dawned on me: <strong>assuming <code>Count</code> is bounded</strong> <span class="post-link">... (<a href="/posts/how-to-build-a-thread-safe-lock-free-resizable-array.html">read the full post</a>)</span></p>
  </section>
</article>
<div class='next-page'>
  <a href='/index6.html'>View older posts</a>
</div>
    <footer>
      <ul class='menu'>
        <li><a href="/posts">All Posts</a></li>
        <li><a href="/about">About</a></li>
        <li>
          <a href='http://stackoverflow.com/users/105570' target='_blank'>
            <img alt='StackOverflow' src='/images/icons/stackoverflow-small.png' />
          </a>
        </li>
        <li>
          <a href='https://github.com/dtao' target='_blank'>
            <img alt='GitHub' src='/images/icons/github-small.png' />
          </a>
        </li>
        <li>
          <a href='https://twitter.com/dan_tao' target='_blank'>
            <img alt='Twitter' src='/images/icons/twitter-small.png' />
          </a>
        </li>
        <li>
          <a href='http://feeds.feedburner.com/philosopherdeveloper'>
            <img alt='RSS' src='/images/icons/rss-small.png' />
          </a>
        </li>
      </ul>
    </footer>
  </body>
</html>
