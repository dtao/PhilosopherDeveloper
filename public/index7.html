<!DOCTYPE html>
<html>
  <head>
    <title>The Philosopher Developer</title>
    <meta charset='utf-8' />
    <meta content='initial-scale=1.0, width=device-width, user-scalable=no' name='viewport' />
    <link href='/stylesheets/application.css' rel='stylesheet' />
    <link href='/stylesheets/pygments.css' rel='stylesheet' />
    <script src='http://w.sharethis.com/button/buttons.js' type='text/javascript'></script>
    <script src='/javascripts/ga.js' type='text/javascript'></script>
    <script src='/javascripts/shareThis.js' type='text/javascript'></script>
    <script src='/javascripts/jquery-1.9.1.min.js' type='text/javascript'></script>
    <!-- I've decided this isn't really worth doing until I make exceptions for -->
    <!-- sites that block iframes. -->
    <!-- %script(type="text/javascript" src="#{SITE_ROOT}/javascripts/main.js") -->
    
    <script type='text/javascript' src='/javascripts/posts.js'></script>
  </head>
  <body>
    <header id='header'>
      <h1><a href="/">The Philosopher Developer</a></h1>
      <h2>half-sound logic, half-decent code</h2>
    </header>
    <article class='abbreviated'>
  <header>
    <h1>
      <span class='title'>
        <a href='/posts/how-i-discovered-a-bug-in-the-csharp-compiler-part-1.html'>How I discovered a bug in the C# compiler, part 1</a>
      </span>
      <span class='date'>March 31, 2011</span>
    </h1>
  </header>
  <section class='content'>
    <p>This is the story of <strong>my epic adventure in discovering a bug in</strong> (the latest version of) <strong>the C# compiler</strong>.</p>

<p>First of all, some background. I was working on a library, mostly for personal use, which was to include an enumerable collection type similar to <code>List&lt;T&gt;</code> or <code>T[]</code>. One of the goals of this library was to be <em>efficient</em>; so, naturally, for this type’s enumerator I made the decision to create a mutable value type.</p>

<p><strong><em>Wait a minute!</em></strong> What’s that, you say? <em>Mutable value types are <strong>evil</strong>!</em> Oh?</p>

<p>This is a topic for a whole other blog post; but just to give a mini-argument in <em>defense</em> of this decision, by way of example, let me point out one simple fact: <strong>if you make the return value of <code>GetEnumerator</code> a <em>reference type</em>, then every <code>foreach</code> loop creates a new object to be garbage collected later</strong>. Don’t care? That’s fine; I <em>did</em> care, so I took an alternate approach (which, incidentally, is the same approach utilized by the designers of the collections in the <code>System.Collections.Generic</code> namespace in the BCL).</p>

<p>For <em>my</em> <code>GetEnumerator</code>, I explicitly implemented both <code>IEnumerable.GetEnumerator</code> <em>and</em> <code>IEnumerable&lt;T&gt;.GetEnumerator</code> and made a public version of the method returning an <code>Enumerator&lt;T&gt;</code> struct, like this:</p>

<div class="highlight"><pre><span class="k">public</span> <span class="n">Enumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">GetEnumerator</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="n">Enumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;.</span><span class="n">GetEnumerator</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="nf">GetEnumerator</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">System</span><span class="p">.</span><span class="n">Collections</span><span class="p">.</span><span class="n">IEnumerator</span> <span class="n">System</span><span class="p">.</span><span class="n">Collections</span><span class="p">.</span><span class="n">IEnumerable</span><span class="p">.</span><span class="n">GetEnumerator</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="nf">GetEnumerator</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>

<p>This allowed my <code>Enumerator&lt;T&gt;</code> type to behave quite well when used in <code>foreach</code> loops without causing unnecessary garbage collection. And the fact that it was a mutable value type hardly mattered—just like it hardly matters for <code>List&lt;T&gt;.Enumerator</code>, <code>Dictionary&lt;TKey, TValue&gt;.Enumerator</code>, etc. (The only times when it hypothetically matters is when you pass an <code>Enumerator&lt;T&gt;</code> value to a method and for some reason <em>expect</em> the code within the method to affect the <span class="post-link">... (<a href="/posts/how-i-discovered-a-bug-in-the-csharp-compiler-part-1.html">read the full post</a>)</span></p>
  </section>
</article>
<article class='abbreviated'>
  <header>
    <h1>
      <span class='title'>
        <a href='/posts/sometimes-the-best-strategy-is-to-retreat.html'>Sometimes the best strategy is to retreat</a>
      </span>
      <span class='date'>February 28, 2011</span>
    </h1>
  </header>
  <section class='content'>
    <p>I have a few remarks to make about <a href="http://dtao.github.com/ConcurrentList/">my <code>ConcurrentList&lt;T&gt;</code> class</a>, which I have written about a <a href="/posts/how-to-build-a-thread-safe-lock-free-resizable-array.html">couple</a> of <a href="/posts/boy-can-dream.html">times</a> already.</p>

<p><em>What, are you “retreating” from your concurrent list idea?</em> In a way, yes. Let me explain. From the beginning, my concept of the usefulness of a lock-free <code>IList&lt;T&gt;</code> implementation was that it would scale better than using a <code>List&lt;T&gt;</code> plus <code>lock</code> statements by eliminating contention when many threads are accessing the list concurrently.</p>

<p>Is this actually true? Accessing the list <code>how</code>?</p>

<p>Since a concurrent implementation of <code>Insert</code>, <code>RemoveAt</code> etc. is not supported in <code>ConcurrentList&lt;T&gt;</code>, there are really only a few operations that need to be considered:</p>

<ul>
<li>Getting/setting an item at a specified index</li>

<li>Adding to the list</li>

<li>Iterating over the list</li>
</ul><p>Critically, I think the assumption is that one would need a lock-free data structure to optimize the scenario where multiple threads may be <em>reading</em> from the list (via accessing items at random indexes) while one or more other threads are <em>adding</em> to it. <strong>I actually don’t think you need a lock-free data structure for this at all.</strong></p>

<p>Here’s the thing: if you’ve got a <code>List&lt;T&gt;</code>, and you synchronize all calls to <code>Add</code> with, e.g., a <code>lock</code> statement, <strong>you don’t need to also synchronize reads</strong>. They will <em>always</em> be thread-safe. Accessing an element at an index of a <code>List&lt;T&gt;</code> that is <em>only</em> growing with calls to <code>Add</code> <em>will</em> work from multiple threads. If you are skeptical, consider what actually happens when <code>Add</code> is called (<strong>warning: reliance upon specific implementation details ahead!</strong>):</p>

<ol>
<li>
<p>The <code>List&lt;T&gt;</code> gets the next available index in its internal array.</p>
</li>

<li>
<p>If the index is beyond the end of the array:</p>

<ol>
<li>A new array is allocated.</li>

<li>The elements of the current array are copied over.</li>

<li>A reference to this new <span class="post-link">... (<a href="/posts/sometimes-the-best-strategy-is-to-retreat.html">read the full post</a>)</span>
</li>
</ol>
</li>
</ol>
  </section>
</article>
<article class='abbreviated'>
  <header>
    <h1>
      <span class='title'>
        <a href='/posts/boy-can-dream.html'>A boy can dream...</a>
      </span>
      <span class='date'>February 24, 2011</span>
    </h1>
  </header>
  <section class='content'>
    <p>Well, I’ve finished an initial implementation of a <code>ConcurrentList&lt;T&gt;</code> data structure. It implements the <code>IList&lt;T&gt;</code> interface (partially—no <code>Insert</code>, <code>RemoveAt</code>, etc.–it is an append-only structure) and is both <strong>thread-safe</strong> and <strong>lock-free</strong>.</p>

<p>(I also came up with a few different ways to resolve the <code>Count</code> issue mentioned in my previous post; what I’ve settled on for now is basically the most obvious and straightforward version.)</p>

<p>The source code for the class itself is available to view in my GitHub repository here:</p>

<p><a href="https://github.com/dtao/ConcurrentList"><strong>Check out the source code.</strong></a></p>

<p>Now for the somewhat disheartening part: thus far, based on my own performance benchmarks, I see little evidence that this actually outperforms a simple <code>List&lt;T&gt;</code> with synchronized calls to <code>Add</code> (using, e.g., a <code>lock</code> statement). So that’s a bit disappointing. But I figured I’d share the source code, in case some hackers out there might be able to figure out how to make it better.</p>

<p>Also, I feel like part of the issue I may be having is that it’s tough to really create a lot of thread contention on a puny little laptop with such a lightweight method (I’d wager <code>List&lt;T&gt;.Add</code> couldn’t be much more than 10 lines). So maybe if this could get tested on a 32-core server somewhere, the results would be more noteworthy. I don’t know!</p>

<p>Anyway, at least it passes the unit tests. That’s got to be worth something, right?</p>
  </section>
</article>
<article class='abbreviated'>
  <header>
    <h1>
      <span class='title'>
        <a href='/posts/how-to-build-a-thread-safe-lock-free-resizable-array.html'>How to build a thread-safe lock-free resizable "array"</a>
      </span>
      <span class='date'>February 23, 2011</span>
    </h1>
  </header>
  <section class='content'>
    <p><strong>Update: I’ve finally (nearly two years later) created a <a href="http://dtao.github.com/ConcurrentList/">dedicated GitHub repo</a> for this.</strong></p>
<hr><p>Inspired by <a href="http://stackoverflow.com/questions/5070495/lock-free-thread-safe-ilistt-for-net">this Stack Overflow question</a>, I started thinking about possible ways of implementing the <code>IList&lt;T&gt;</code> interface in a lock-free <em>concurrent</em> data structure, with the following notes:</p>

<ol>
<li>I highly doubt a lock-free <code>Insert</code> or <code>RemoveAt</code> implementation is possible. I could be wrong, of course; but I don’t think so. So I would implement those explicitly (and throw a <code>NotSupportedException</code>).</li>

<li>I would want guaranteed O(1) random access, at least. (Otherwise, the whole point of implementing <code>IList&lt;T&gt;</code> seems kind of questionable.)</li>
</ol><p>OK, so, <strong>how do we do it</strong>?</p>

<p>Before I even describe my idea (still a work in progress), I should disclose the fact that, to my simultaneous disappointment and delight, it appears I managed to come up with a concept on my own that is <em>remarkably</em> similar to what researchers at Texas A&amp;M University, including <a href="http://en.wikipedia.org/wiki/Bjarne_Stroustrup">Bjarne Stroustrup</a>, <a href="http://www.stroustrup.com/lock-free-vector.pdf">designed and published</a>.</p>

<p>Here’s the basic idea. Clearly utilizing a single array that is resized on certain Add operations would be problematic: allocating a new array and copying all elements to it in a lock-free way would be, at least I have to speculate, quite costly (imagine multiple concurrent threads all copying elements concurrently—seems very wasteful). So I considered using a <em>linked list</em> of arrays, where when an Add call requires additional storage, a new array could be allocated and appended to the linked list. But once you introduce a linked list, random access in O(1) becomes, well, less possible.</p>

<p>I was <em>thinking</em> you probably couldn’t do it with a simple array of arrays (e.g., a <code>List&lt;T[]&gt;</code>) simply because then you’d eventually run into the problem of having to resize the “outer” array eventually. But then it dawned on me: <strong>assuming <code>Count</code> is bounded</strong> <span class="post-link">... (<a href="/posts/how-to-build-a-thread-safe-lock-free-resizable-array.html">read the full post</a>)</span></p>
  </section>
</article>
<article class='abbreviated'>
  <header>
    <h1>
      <span class='title'>
        <a href='/posts/tempted-by-linq.html'>Tempted by LINQ? Stop and think</a>
      </span>
      <span class='date'>February 09, 2011</span>
    </h1>
  </header>
  <section class='content'>
    <p>LINQ is a really awesome tool for .NET developers, just like a hammer is a really awesome tool for a carpenter. But here’s the thing.</p>

<p>Sometimes I feel like, before LINQ, a .NET developer was akin to a carpenter without a hammer. And then the hammer came along, and carpenters the world over <em>totally</em> fell in love with it. It helped them get so many tasks done more quickly than they could before. But this led them to start using hammers in totally unintended ways.</p>

<p>These carpenters would attend meetings where they would ask questions like, “Does anyone know how to use a hammer as a level?” and “Who can show me how to tighten bolts using my hammer?” Some of the older carpenters at these meetings would shake their heads knowingly, while others would enthusiastically chime in with their clever and novel uses for hammers.</p>

<p>Guys, LINQ is just <strong>one tool</strong>. A carpenter wouldn’t use a hammer for every single task he needs to accomplish. Likewise, we should not be using this <em>one</em> feature of .NET to do everything having anything to do with collections within the language.</p>

<p>This is <em>particularly</em> important to me, because I work on code that must be high-performance all the time at work. I remember when I first introduced my teammates to LINQ; one developer on the team in particular got very excited and started using LINQ extension methods all over the place. For example we would find code like this:</p>

<div class="highlight"><pre><span class="k">For</span> <span class="k">Each</span> <span class="n">prod</span> <span class="ow">As</span> <span class="n">Product</span> <span class="ow">In</span> <span class="n">Products</span><span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">Function</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="n">p</span><span class="p">.</span><span class="n">IsQuoting</span><span class="p">).</span><span class="n">OrderBy</span><span class="p">(</span><span class="n">Function</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="n">p</span><span class="p">.</span><span class="n">Expiration</span><span class="p">).</span><span class="n">ThenBy</span><span class="p">(</span><span class="n">Function</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="n">p</span><span class="p">.</span><span class="n">Strike</span><span class="p">)</span>
    <span class="n">prod</span><span class="p">.</span><span class="n">SendQuotes</span><span class="p">()</span>
<span class="k">Next</span>
</pre></div>

<p>Yeah, that’s <em>terrible</em>. <strong>It’s like using a hammer to perform brain surgery.</strong> But how was my teammate to know, or even suspect there was anything wrong with what he was doing?</p>

<p>I think the .NET culture has embraced LINQ <span class="post-link">... (<a href="/posts/tempted-by-linq.html">read the full post</a>)</span></p>
  </section>
</article>
<div class='next-page'>
  <a href='/index8.html'>View older posts</a>
</div>
    <footer>
      <ul class='menu'>
        <li><a href="/posts">All Posts</a></li>
        <li><a href="/about">About</a></li>
        <li>
          <a href='http://stackoverflow.com/users/105570' target='_blank'>
            <img alt='StackOverflow' src='/images/icons/stackoverflow-small.png' />
          </a>
        </li>
        <li>
          <a href='https://github.com/dtao' target='_blank'>
            <img alt='GitHub' src='/images/icons/github-small.png' />
          </a>
        </li>
        <li>
          <a href='https://twitter.com/dan_tao' target='_blank'>
            <img alt='Twitter' src='/images/icons/twitter-small.png' />
          </a>
        </li>
        <li>
          <a href='http://feeds.feedburner.com/philosopherdeveloper'>
            <img alt='RSS' src='/images/icons/rss-small.png' />
          </a>
        </li>
      </ul>
    </footer>
  </body>
</html>
