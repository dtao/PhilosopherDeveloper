<!DOCTYPE html>
<html>
  <head>
    <title>The Philosopher Developer</title>
    <meta charset='utf-8' />
    <meta content='initial-scale=1.0, width=device-width, user-scalable=no' name='viewport' />
    <link href='/stylesheets/application.css' rel='stylesheet' />
    <link href='/stylesheets/pygments.css' rel='stylesheet' />
    <script src='http://w.sharethis.com/button/buttons.js' type='text/javascript'></script>
    <script src='/javascripts/ga.js' type='text/javascript'></script>
    <script src='/javascripts/shareThis.js' type='text/javascript'></script>
    <script src='/javascripts/jquery-1.9.1.min.js' type='text/javascript'></script>
    <script src='/javascripts/main.js' type='text/javascript'></script>
    
    <script type='text/javascript' src='/javascripts/posts.js'></script>
  </head>
  <body>
    <header id='header'>
      <h1><a href="/">The Philosopher Developer</a></h1>
      <h2>half-sound logic, half-decent code</h2>
    </header>
    <article class='abbreviated'>
  <header>
    <h1>
      <span class='title'>
        <a href='/posts/how-i-discovered-a-bug-in-the-csharp-compiler-part-1.html'>How I discovered a bug in the C# compiler, part 1</a>
      </span>
      <span class='date'>March 31, 2011</span>
    </h1>
  </header>
  <section class='content'>
    <p>Well, <a href="http://philosopherdeveloper.wordpress.com/2011/03/25/poll-what-should-my-next-blog-topic-be/">a few of you voted</a>, and this topic came out on top. So, without further ado, I give you the story of <strong>my epic adventure in discovering a bug in</strong> (the latest version of) <strong>the C# compiler</strong>.</p>

<p>First of all, some background. I was working on a library, mostly for personal use, which was to include an enumerable collection type similar to <code>List&lt;T&gt;</code> or <code>T[]</code>. One of the goals of this library was to be <em>efficient</em>; so, naturally, for this type’s enumerator I made the decision to create a mutable value type.</p>

<p><strong><em>Wait a minute!</em></strong> What’s that, you say? <em>Mutable value types are <strong>evil</strong>!</em> Oh?</p>

<p>This is a topic for a whole other blog post; but just to give a mini-argument in <em>defense</em> of this decision, by way of example, let me point out one simple fact: <strong>if you make the return value of <code>GetEnumerator</code> a <em>reference type</em>, then every <code>foreach</code> loop creates a new object to be garbage collected later</strong>. Don’t care? That’s fine; I <em>did</em> care, so I took an alternate approach (which, incidentally, is the same approach utilized by the designers of the collections in the <code>System.Collections.Generic</code> namespace in the BCL).</p>

<p>For <em>my</em> <code>GetEnumerator</code>, I explicitly implemented both <code>IEnumerable.GetEnumerator</code> <em>and</em> <code>IEnumerable&lt;T&gt;.GetEnumerator</code> and made a public version of the method returning an <code>Enumerator&lt;T&gt;</code> struct, like this:</p>

<div class="highlight"><pre><span class="k">public</span> <span class="n">Enumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">GetEnumerator</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="n">Enumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;.</span><span class="n">GetEnumerator</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="nf">GetEnumerator</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">System</span><span class="p">.</span><span class="n">Collections</span><span class="p">.</span><span class="n">IEnumerator</span> <span class="n">System</span><span class="p">.</span><span class="n">Collections</span><span class="p">.</span><span class="n">IEnumerable</span><span class="p">.</span><span class="n">GetEnumerator</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="nf">GetEnumerator</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>

<p>This allowed my <code>Enumerator&lt;T&gt;</code> type to behave quite well when used in <code>foreach</code> loops without causing unnecessary garbage collection. And the fact that it was a mutable value type hardly mattered—just like it hardly matters for <code>List&lt;T&gt;.Enumerator</code>, <code>Dictionary&lt;TKey, TValue&gt;.Enumerator</code>, etc. (The only times when it hypothetically matters is when you pass <span class="post-link">... (<a href="/posts/how-i-discovered-a-bug-in-the-csharp-compiler-part-1.html">read the full post</a>)</span></p>
  </section>
</article>
<article class='abbreviated'>
  <header>
    <h1>
      <span class='title'>
        <a href='/posts/sometimes-the-best-strategy-is-to-retreat.html'>Sometimes the best strategy is to retreat</a>
      </span>
      <span class='date'>February 28, 2011</span>
    </h1>
  </header>
  <section class='content'>
    <p>I have a few remarks to make about <a href="http://dtao.github.com/ConcurrentList/">my <code>ConcurrentList&lt;T&gt;</code> class</a>, which I have written about a <a href="/posts/how-to-build-a-thread-safe-lock-free-resizable-array.html">couple</a> of <a href="/posts/boy-can-dream.html">times</a> already.</p>

<p><em>What, are you “retreating” from your concurrent list idea?</em> In a way, yes. Let me explain. From the beginning, my concept of the usefulness of a lock-free <code>IList&lt;T&gt;</code> implementation was that it would scale better than using a <code>List&lt;T&gt;</code> plus <code>lock</code> statements by eliminating contention when many threads are accessing the list concurrently.</p>

<p>Is this actually true? Accessing the list <code>how</code>?</p>

<p>Since a concurrent implementation of <code>Insert</code>, <code>RemoveAt</code> etc. is not supported in <code>ConcurrentList&lt;T&gt;</code>, there are really only a few operations that need to be considered:</p>

<ul>
<li>Getting/setting an item at a specified index</li>

<li>Adding to the list</li>

<li>Iterating over the list</li>
</ul><p>Critically, I think the assumption is that one would need a lock-free data structure to optimize the scenario where multiple threads may be <em>reading</em> from the list (via accessing items at random indexes) while one or more other threads are <em>adding</em> to it. <strong>I actually don’t think you need a lock-free data structure for this at all.</strong></p>

<p>Here’s the thing: if you’ve got a <code>List&lt;T&gt;</code>, and you synchronize all calls to <code>Add</code> with, e.g., a <code>lock</code> statement, <strong>you don’t need to also synchronize reads</strong>. They will <em>always</em> be thread-safe. Accessing an element at an index of a <code>List&lt;T&gt;</code> that is <em>only</em> growing with calls to <code>Add</code> <em>will</em> work from multiple threads. If you are skeptical, consider what actually happens when <code>Add</code> is called (<strong>warning: reliance upon specific implementation details ahead!</strong>):</p>

<ol>
<li>
<p>The <code>List&lt;T&gt;</code> gets the next available index in its internal array.</p>
</li>

<li>
<p>If the index is beyond the end of the array:</p>

<ol>
<li>A new array is allocated.</li>

<li>The elements of the current array are copied over.</li>

<li>A reference to this new <span class="post-link">... (<a href="/posts/sometimes-the-best-strategy-is-to-retreat.html">read the full post</a>)</span>
</li>
</ol>
</li>
</ol>
  </section>
</article>
<article class='abbreviated'>
  <header>
    <h1>
      <span class='title'>
        <a href='/posts/boy-can-dream.html'>A boy can dream...</a>
      </span>
      <span class='date'>February 24, 2011</span>
    </h1>
  </header>
  <section class='content'>
    <p>Well, I’ve finished an initial implementation of a <code>ConcurrentList&lt;T&gt;</code> data structure. It implements the <code>IList&lt;T&gt;</code> interface (partially—no <code>Insert</code>, <code>RemoveAt</code>, etc.–it is an append-only structure) and is both <strong>thread-safe</strong> and <strong>lock-free</strong>.</p>

<p>(I also came up with a few different ways to resolve the <code>Count</code> issue mentioned in my previous post; what I’ve settled on for now is basically the most obvious and straightforward version.)</p>

<p>The source code for the class itself is available to view in my GitHub repository here:</p>

<p><a href="https://github.com/dtao/ConcurrentList"><strong>Check out the source code.</strong></a></p>

<p>Now for the somewhat disheartening part: thus far, based on my own performance benchmarks, I see little evidence that this actually outperforms a simple <code>List&lt;T&gt;</code> with synchronized calls to <code>Add</code> (using, e.g., a <code>lock</code> statement). So that’s a bit disappointing. But I figured I’d share the source code, in case some hackers out there might be able to figure out how to make it better.</p>

<p>Also, I feel like part of the issue I may be having is that it’s tough to really create a lot of thread contention on a puny little laptop with such a lightweight method (I’d wager <code>List&lt;T&gt;.Add</code> couldn’t be much more than 10 lines). So maybe if this could get tested on a 32-core server somewhere, the results would be more noteworthy. I don’t know!</p>

<p>Anyway, at least it passes the unit tests. That’s got to be worth something, right?</p>
  </section>
</article>
<article class='abbreviated'>
  <header>
    <h1>
      <span class='title'>
        <a href='/posts/how-to-build-a-thread-safe-lock-free-resizable-array.html'>How to build a thread-safe lock-free resizable "array"</a>
      </span>
      <span class='date'>February 23, 2011</span>
    </h1>
  </header>
  <section class='content'>
    <p><strong>Update: I’ve finally (nearly two years later) created a <a href="http://dtao.github.com/ConcurrentList/">dedicated GitHub repo</a> for this.</strong></p>
<hr><p>Inspired by <a href="http://stackoverflow.com/questions/5070495/lock-free-thread-safe-ilistt-for-net">this Stack Overflow question</a>, I started thinking about possible ways of implementing the <code>IList&lt;T&gt;</code> interface in a lock-free <em>concurrent</em> data structure, with the following notes:</p>

<ol>
<li>I highly doubt a lock-free <code>Insert</code> or <code>RemoveAt</code> implementation is possible. I could be wrong, of course; but I don’t think so. So I would implement those explicitly (and throw a <code>NotSupportedException</code>).</li>

<li>I would want guaranteed O(1) random access, at least. (Otherwise, the whole point of implementing <code>IList&lt;T&gt;</code> seems kind of questionable.)</li>
</ol><p>OK, so, <strong>how do we do it</strong>?</p>

<p>Before I even describe my idea (still a work in progress), I should disclose the fact that, to my simultaneous disappointment and delight, it appears I managed to come up with a concept on my own that is <em>remarkably</em> similar to what researchers at Texas A&amp;M University, including <a href="http://en.wikipedia.org/wiki/Bjarne_Stroustrup">Bjarne Stroustrup</a>, <a href="http://www.stroustrup.com/lock-free-vector.pdf">designed and published</a>.</p>

<p>Here’s the basic idea. Clearly utilizing a single array that is resized on certain Add operations would be problematic: allocating a new array and copying all elements to it in a lock-free way would be, at least I have to speculate, quite costly (imagine multiple concurrent threads all copying elements concurrently—seems very wasteful). So I considered using a <em>linked list</em> of arrays, where when an Add call requires additional storage, a new array could be allocated and appended to the linked list. But once you introduce a linked list, random access in O(1) becomes, well, less possible.</p>

<p>I was <em>thinking</em> you probably couldn’t do it with a simple array of arrays (e.g., a <code>List&lt;T[]&gt;</code>) simply because then you’d eventually run into the problem of having to resize the “outer” array eventually. But then it dawned on me: <strong>assuming <code>Count</code> is bounded</strong> <span class="post-link">... (<a href="/posts/how-to-build-a-thread-safe-lock-free-resizable-array.html">read the full post</a>)</span></p>
  </section>
</article>
<article class='abbreviated'>
  <header>
    <h1>
      <span class='title'>
        <a href='/posts/multithreading-and-multitasking.html'>Multithreading and multitasking</a>
      </span>
      <span class='date'>February 04, 2011</span>
    </h1>
  </header>
  <section class='content'>
    <p>Watch the following video and count how many times the players in white pass the basketball. Then scroll down to read the rest of this post.</p>
    
    <p class="centered">.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.</p>
    
    <p><strong>Did you see the gorilla?</strong> OK, the truth is: <em>I</em> did, but only because I was expecting it (the name of the website where I first saw the video, <a href="http://www.theinvisiblegorilla.com/">The Invisible Gorilla</a>, kind of gives it away). Apparently a lot of viewers do <em>not</em> see the gorilla, though, because they are too busy focusing on the people throwing and catching the ball to notice it.</p>
    
    <p>It’s a fairly well-documented fact at this point that <a href="http://www.npr.org/templates/story/story.php?storyId=95256794">human beings are not so good at multitasking</a> (the fact that that link points to a 2-year-old article right there tells you that this is not news). Rather, we are very quick at <a href="http://en.wikipedia.org/wiki/Context_switching"><em>context-switching</em></a>.</p>
    
    <p>Those of you software engineers reading this: does that term sound familiar? I thought so. <strong>Context switching</strong> is the process of suspending and restoring the state of different <a href="http://en.wikipedia.org/wiki/Thread_%28computer_science%29"><em>threads</em></a> or <em>processes</em> on a single CPU. More simply, it is akin to shifting one’s attention back and forth between multiple things. A good example would be driving while talking on the phone. It’s actually impossible to pay attention to both simultaneously, according to neuroscientists; rather, what you are likely able to do when driving while talking is <em>switch</em> between thinking about your driving and thinking about your phone conversation, very rapidly:</p>
    
    <figure><img src="/images/context-switching.png" alt="An illustration of context switching between driving and talking"><figcaption>An illustration of context switching between driving and talking</figcaption></figure>
    
    <p>Computers are exactly like this too. This is becoming less true now that dual-core, quad-core, even six-core processors (this will likely only keep increasing) have become the norm, at least on desktop computers (and <em>especially</em> on servers, where 24 cores or more is not at <span class="post-link">... (<a href="/posts/multithreading-and-multitasking.html">read the full post</a>)</span></p>
  </section>
</article>
<div class='next-page'>
  <a href='/index7.html'>View older posts</a>
</div>
    <footer>
      <ul class='menu'>
        <li><a href="/posts">All Posts</a></li>
        <li><a href="/about">About</a></li>
        <li>
          <a href='http://stackoverflow.com/users/105570' target='_blank'>
            <img alt='StackOverflow' src='/images/icons/stackoverflow-small.png' />
          </a>
        </li>
        <li>
          <a href='https://github.com/dtao' target='_blank'>
            <img alt='GitHub' src='/images/icons/github-small.png' />
          </a>
        </li>
        <li>
          <a href='https://twitter.com/dan_tao' target='_blank'>
            <img alt='Twitter' src='/images/icons/twitter-small.png' />
          </a>
        </li>
        <li>
          <a href='http://feeds.feedburner.com/philosopherdeveloper'>
            <img alt='RSS' src='/images/icons/rss-small.png' />
          </a>
        </li>
      </ul>
    </footer>
  </body>
</html>
