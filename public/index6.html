<!DOCTYPE html>
<html>
  <head>
    <title>The Philosopher Developer</title>
    <meta charset='utf-8' />
    <meta content='initial-scale=1.0, width=device-width, user-scalable=no' name='viewport' />
    <link href='/stylesheets/application.css' rel='stylesheet' />
    <link href='/stylesheets/pygments.css' rel='stylesheet' />
    <script src='http://w.sharethis.com/button/buttons.js' type='text/javascript'></script>
    <script src='/javascripts/ga.js' type='text/javascript'></script>
    <script src='/javascripts/shareThis.js' type='text/javascript'></script>
    <script src='/javascripts/jquery-1.9.1.min.js' type='text/javascript'></script>
    <script src='/javascripts/main.js' type='text/javascript'></script>
    
    <script type='text/javascript' src='/javascripts/posts.js'></script>
  </head>
  <body>
    <header id='header'>
      <h1><a href="/">The Philosopher Developer</a></h1>
      <h2>half-sound logic, half-decent code</h2>
    </header>
    <article class='abbreviated'>
  <header>
    <h1>
      <span class='title'>
        <a href='/posts/how-i-discovered-a-bug-in-the-csharp-compiler-part-1.html'>How I discovered a bug in the C# compiler, part 1</a>
      </span>
      <span class='date'>March 31, 2011</span>
    </h1>
  </header>
  <section class='content'>
    <p>Well, <a href="http://philosopherdeveloper.wordpress.com/2011/03/25/poll-what-should-my-next-blog-topic-be/">a few of you voted</a>, and this topic came out on top. So, without further ado, I give you the story of <strong>my epic adventure in discovering a bug in</strong> (the latest version of) <strong>the C# compiler</strong>.</p>

<p>First of all, some background. I was working on a library, mostly for personal use, which was to include an enumerable collection type similar to <code>List&lt;T&gt;</code> or <code>T[]</code>. One of the goals of this library was to be <em>efficient</em>; so, naturally, for this type’s enumerator I made the decision to create a mutable value type.</p>

<p><strong><em>Wait a minute!</em></strong> What’s that, you say? <em>Mutable value types are <strong>evil</strong>!</em> Oh?</p>

<p>This is a topic for a whole other blog post; but just to give a mini-argument in <em>defense</em> of this decision, by way of example, let me point out one simple fact: <strong>if you make the return value of <code>GetEnumerator</code> a <em>reference type</em>, then every <code>foreach</code> loop creates a new object to be garbage collected later</strong>. Don’t care? That’s fine; I <em>did</em> care, so I took an alternate approach (which, incidentally, is the same approach utilized by the designers of the collections in the <code>System.Collections.Generic</code> namespace in the BCL).</p>

<p>For <em>my</em> <code>GetEnumerator</code>, I explicitly implemented both <code>IEnumerable.GetEnumerator</code> <em>and</em> <code>IEnumerable&lt;T&gt;.GetEnumerator</code> and made a public version of the method returning an <code>Enumerator&lt;T&gt;</code> struct, like this:</p>

<div class="highlight"><pre><span class="k">public</span> <span class="n">Enumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">GetEnumerator</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="n">Enumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;.</span><span class="n">GetEnumerator</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="nf">GetEnumerator</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">System</span><span class="p">.</span><span class="n">Collections</span><span class="p">.</span><span class="n">IEnumerator</span> <span class="n">System</span><span class="p">.</span><span class="n">Collections</span><span class="p">.</span><span class="n">IEnumerable</span><span class="p">.</span><span class="n">GetEnumerator</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="nf">GetEnumerator</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>

<p>This allowed my <code>Enumerator&lt;T&gt;</code> type to behave quite well when used in <code>foreach</code> loops without causing unnecessary garbage collection. And the fact that it was a mutable value type hardly mattered—just like it hardly matters for <code>List&lt;T&gt;.Enumerator</code>, <code>Dictionary&lt;TKey, TValue&gt;.Enumerator</code>, etc. (The only times when it hypothetically matters is when you pass <span class="post-link">... (<a href="/posts/how-i-discovered-a-bug-in-the-csharp-compiler-part-1.html">read the full post</a>)</span></p>
  </section>
</article>
<article class='abbreviated'>
  <header>
    <h1>
      <span class='title'>
        <a href='/posts/sometimes-the-best-strategy-is-to-retreat.html'>Sometimes the best strategy is to retreat</a>
      </span>
      <span class='date'>February 28, 2011</span>
    </h1>
  </header>
  <section class='content'>
    <p>I have a few remarks to make about <a href="http://dtao.github.com/ConcurrentList/">my <code>ConcurrentList&lt;T&gt;</code> class</a>, which I have written about a <a href="/posts/how-to-build-a-thread-safe-lock-free-resizable-array.html">couple</a> of <a href="/posts/boy-can-dream.html">times</a> already.</p>

<p><em>What, are you “retreating” from your concurrent list idea?</em> In a way, yes. Let me explain. From the beginning, my concept of the usefulness of a lock-free <code>IList&lt;T&gt;</code> implementation was that it would scale better than using a <code>List&lt;T&gt;</code> plus <code>lock</code> statements by eliminating contention when many threads are accessing the list concurrently.</p>

<p>Is this actually true? Accessing the list <code>how</code>?</p>

<p>Since a concurrent implementation of <code>Insert</code>, <code>RemoveAt</code> etc. is not supported in <code>ConcurrentList&lt;T&gt;</code>, there are really only a few operations that need to be considered:</p>

<ul>
<li>Getting/setting an item at a specified index</li>

<li>Adding to the list</li>

<li>Iterating over the list</li>
</ul>

<p>Critically, I think the assumption is that one would need a lock-free data structure to optimize the scenario where multiple threads may be <em>reading</em> from the list (via accessing items at random indexes) while one or more other threads are <em>adding</em> to it. <strong>I actually don’t think you need a lock-free data structure for this at all.</strong></p>

<p>Here’s the thing: if you’ve got a <code>List&lt;T&gt;</code>, and you synchronize all calls to <code>Add</code> with, e.g., a <code>lock</code> statement, <strong>you don’t need to also synchronize reads</strong>. They will <em>always</em> be thread-safe. Accessing an element at an index of a <code>List&lt;T&gt;</code> that is <em>only</em> growing with calls to <code>Add</code> <em>will</em> work from multiple threads. If you are skeptical, consider what actually happens when <code>Add</code> is called (<strong>warning: reliance upon specific implementation details ahead!</strong>):</p>

<ol>
<li>
<p>The <code>List&lt;T&gt;</code> gets the next available index in its internal array.</p>
</li>

<li>
<p>If the index is beyond the end of the array:</p>

<ol>
<li>A new array is allocated.</li>

<li>The elements of the current array are copied over.</li>

<li>A reference to this new <span class="post-link">... (<a href="/posts/sometimes-the-best-strategy-is-to-retreat.html">read the full post</a>)</span>
</li>
</ol>
</li>
</ol>
  </section>
</article>
<article class='abbreviated'>
  <header>
    <h1>
      <span class='title'>
        <a href='/posts/boy-can-dream.html'>A boy can dream...</a>
      </span>
      <span class='date'>February 24, 2011</span>
    </h1>
  </header>
  <section class='content'>
    <p>Well, I’ve finished an initial implementation of a <code>ConcurrentList&lt;T&gt;</code> data structure. It implements the <code>IList&lt;T&gt;</code> interface (partially—no <code>Insert</code>, <code>RemoveAt</code>, etc.–it is an append-only structure) and is both <strong>thread-safe</strong> and <strong>lock-free</strong>.</p>

<p>(I also came up with a few different ways to resolve the <code>Count</code> issue mentioned in my previous post; what I’ve settled on for now is basically the most obvious and straightforward version.)</p>

<p>The source code for the class itself is available to view in my GitHub repository here:</p>

<p><a href="https://github.com/dtao/ConcurrentList"><strong>Check out the source code.</strong></a></p>

<p>Now for the somewhat disheartening part: thus far, based on my own performance benchmarks, I see little evidence that this actually outperforms a simple <code>List&lt;T&gt;</code> with synchronized calls to <code>Add</code> (using, e.g., a <code>lock</code> statement). So that’s a bit disappointing. But I figured I’d share the source code, in case some hackers out there might be able to figure out how to make it better.</p>

<p>Also, I feel like part of the issue I may be having is that it’s tough to really create a lot of thread contention on a puny little laptop with such a lightweight method (I’d wager <code>List&lt;T&gt;.Add</code> couldn’t be much more than 10 lines). So maybe if this could get tested on a 32-core server somewhere, the results would be more noteworthy. I don’t know!</p>

<p>Anyway, at least it passes the unit tests. That’s got to be worth something, right?</p>
  </section>
</article>
<article class='abbreviated'>
  <header>
    <h1>
      <span class='title'>
        <a href='/posts/how-to-build-a-thread-safe-lock-free-resizable-array.html'>How to build a thread-safe lock-free resizable "array"</a>
      </span>
      <span class='date'>February 23, 2011</span>
    </h1>
  </header>
  <section class='content'>
    <p><strong>Update: I’ve finally (nearly two years later) created a <a href="http://dtao.github.com/ConcurrentList/">dedicated GitHub repo</a> for this.</strong></p>
<hr>
<p>Inspired by <a href="http://stackoverflow.com/questions/5070495/lock-free-thread-safe-ilistt-for-net">this Stack Overflow question</a>, I started thinking about possible ways of implementing the <code>IList&lt;T&gt;</code> interface in a lock-free <em>concurrent</em> data structure, with the following notes:</p>

<ol>
<li>I highly doubt a lock-free <code>Insert</code> or <code>RemoveAt</code> implementation is possible. I could be wrong, of course; but I don’t think so. So I would implement those explicitly (and throw a <code>NotSupportedException</code>).</li>

<li>I would want guaranteed O(1) random access, at least. (Otherwise, the whole point of implementing <code>IList&lt;T&gt;</code> seems kind of questionable.)</li>
</ol>

<p>OK, so, <strong>how do we do it</strong>?</p>

<p>Before I even describe my idea (still a work in progress), I should disclose the fact that, to my simultaneous disappointment and delight, it appears I managed to come up with a concept on my own that is <em>remarkably</em> similar to what researchers at Texas A&amp;M University, including <a href="http://en.wikipedia.org/wiki/Bjarne_Stroustrup">Bjarne Stroustrup</a>, <a href="http://www.stroustrup.com/lock-free-vector.pdf">designed and published</a>.</p>

<p>Here’s the basic idea. Clearly utilizing a single array that is resized on certain Add operations would be problematic: allocating a new array and copying all elements to it in a lock-free way would be, at least I have to speculate, quite costly (imagine multiple concurrent threads all copying elements concurrently—seems very wasteful). So I considered using a <em>linked list</em> of arrays, where when an Add call requires additional storage, a new array could be allocated and appended to the linked list. But once you introduce a linked list, random access in O(1) becomes, well, less possible.</p>

<p>I was <em>thinking</em> you probably couldn’t do it with a simple array of arrays (e.g., a <code>List&lt;T[]&gt;</code>) simply because then you’d eventually run into the problem of having to resize the “outer” array eventually. But then it dawned on me: <strong>assuming <code>Count</code> is bounded</strong> <span class="post-link">... (<a href="/posts/how-to-build-a-thread-safe-lock-free-resizable-array.html">read the full post</a>)</span></p>
  </section>
</article>
<article class='abbreviated'>
  <header>
    <h1>
      <span class='title'>
        <a href='/posts/terminating-condition.html'>Resolution: the need for a terminating condition</a>
      </span>
      <span class='date'>January 15, 2011</span>
    </h1>
  </header>
  <section class='content'>
    <p>For reasons not relevant to this blog, I have been thinking a lot lately about personal conflicts and how they evolve. In particular, my mind has been concentrating a great deal on the scenario of conflicts <em>escalating</em>: for example, the phenomenon where two people are having a regular conversation, and this somehow leads to a disagreement, and eventually the situation develops into an all-out shouting match with both parties so angry with each other that it’s often baffling to recall how the conversation began.</p>

<p>This can happen over a short or a long period of <strong>time</strong>. It can take place within a single ten-minute conversation; it can also span days, months, even <em>years</em> (in this case it might be the cause of a friendship’s disintegration). It can also occur on a small or large <strong>scale</strong>. It might occur between friends, families, communities, even <em>nations</em> (throughout history, what war has not started as a smaller disagreement that eventually grew to something much larger?). I think we’ve all seen it happen, sadly, probably numerous times.</p>

<p>As I am a software developer, I often perceive parallels between <em>real-world phenomena</em> and <em>software concepts</em>. What I want to do right now is to discuss one such parallel: the similarity between <strong>escalating conflict</strong> (the real-world phenomenon) and <strong>mutual recursion</strong> (the software concept).</p>

<p><strong>A note to those readers who aren’t programmers: I will be including some source code in this post, but don’t stop reading! I promise that this discussion is of a general nature and not strictly programming-related.</strong></p>

<p>For those who can read it, consider the following code snippet:</p>

<div class="highlight"><pre><span class="k">void</span> <span class="nf">Provoke</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">"Provoke!"</span><span class="p">);</span>
    <span class="n">Respond</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">Respond</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">"Respond!"</span><span class="p">);</span>
    <span class="n">Provoke</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>

<p>If I were to ask you, <em>What does the above code do?</em>, an initial response might be that <span class="post-link">... (<a href="/posts/terminating-condition.html">read the full post</a>)</span></p>
  </section>
</article>
    <footer>
      <ul class='menu'>
        <li><a href="/posts">All Posts</a></li>
        <li><a href="/about">About</a></li>
        <li>
          <a href='http://stackoverflow.com/users/105570' target='_blank'>
            <img alt='StackOverflow' src='/images/icons/stackoverflow-small.png' />
          </a>
        </li>
        <li>
          <a href='https://github.com/dtao' target='_blank'>
            <img alt='GitHub' src='/images/icons/github-small.png' />
          </a>
        </li>
        <li>
          <a href='https://twitter.com/dan_tao' target='_blank'>
            <img alt='Twitter' src='/images/icons/twitter-small.png' />
          </a>
        </li>
        <li>
          <a href='http://feeds.feedburner.com/philosopherdeveloper'>
            <img alt='RSS' src='/images/icons/rss-small.png' />
          </a>
        </li>
      </ul>
    </footer>
  </body>
</html>
